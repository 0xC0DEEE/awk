% vim: ts=4 sts=4 sw=4 et tw=75
\chapter{部分习题答案}
\label{chap:answers_to_selected_exercises}
\marginpar{193}

\exer\ref{exer:sum3} 一个比较简单的, 用来忽略空白行的方式是把 \texttt{sum3}
的第1行替换成
\begin{awkcode}
        nfld == 0 && NF > 0 { nfld = NF
\end{awkcode}

\exer\ref{exer:without_for_test} 如果缺了这个条件判断, 非数值列的和仍然
    会被累加, 但不会被打印出来. 当累加到某些无用的总和时, 可能会出现一些
    错误(例如溢出), 而该条件判断可以避免这这种情况出现, 而且并不会对程序
    的运行效率产生明显的影响.

\exer\ref{exer:accumulate} 使用关联数组的话, 这道题就容易多了:
\begin{awkcode}
        { total[$1] += $2 }
    END { for (x in total) print x, total[x] | "sort" }
\end{awkcode}

\exer\ref{exer:star_num} 假定一行内至多只能有 25 个星号. 把 \texttt{max} 
设置为 25, 如果最长的行不会超过上限, 那么下面的程序就不会对数据进行更改,
    否则的话, 就对每一行按照比例进行缩放, 使得最长的行不会超过 25 个星号.
新数组 \texttt{y} 用来维护缩放后的长度, 这样的话, 数组 \texttt{x} 的元素
仍然是有效的.
\begin{awkcode}
        { x[int($1/10)]++ }
    END { max = MAXSTARS = 25
          for (i = 0; i <= 10; i++)
              if (x[i] > max)
                  max = x[i]
          for (i = 0; i <= 10; i++)
              y[i] = x[i]/max * MAXSTARS
          for (i = 0; i < 10; i++)
              printf(" %2d - %2d: %3d %s\n",
                  10*i, 10*i+9, x[i], rep(y[i],"*"))
          printf("100:      %3d %s\n", x[10], rep(y[10],"*"))
        }

    function rep(n,s,   t) {  # return string of n s's
        while (n-- > 0)
            t = t s
        return t
    }
\end{awkcode}

\exer\ref{exer:bucket} 需要对数据遍历两遍, 其中 1 遍确定桶的范围, 另 1 
    遍把条目分配到桶中.
    
\marginpar{194}
\exer\ref{exer:sumcomma} 逗号在数字中如何放置 --- 对于这个问题并没有一个
明确的定义, 如果不考虑软件工程的标准, 比较常见的情况是即使对问题不是非常
清楚, 但也必须加以解决. 对这道题有两种可能的答案. 下面的程序对整数求和,
而这些整数中的逗号都处在传统的位置上:
\begin{awkcode}
    /^[+-]?[0-9][0-9]?[0-9]?(,[0-9][0-9][0-9])*$/ {
            gsub(/,/, "")
            sum += $0
            next
    }
          { print "bad format:", $0 }
    END   { print sum }
\end{awkcode}
一般来说, 逗号不会出现在小数点之后, 程序 
\begin{awkcode}
    /^[+-]?[0-9][0-9]?[0-9]?(,[0-9][0-9][0-9])*([.][0-9]*)?$/ {
            gsub(/,/, "")
            sum += $0
            next
    }
          { print "bad format:", $0}
    END   { print sum }
\end{awkcode}
所求和的数值, 其在小数点之前含有逗号和至少一个数字.

\exer\ref{exer:date} 函数 \texttt{daynum(y,m,d)} 返回某个日期自 1901 年 
1 月 1 号以来经过的天数, 日期的格式是 \textit{year month day}, 比如 
\texttt{2001 4 1}. 闰年的 二月有 29 天, 闰年的判断标准是年份可以被 4 整除,
但不能被 100 整除, 或者能直接被 400 整除, 于是 1900 年和2100年都不是
闰年 (它们能被 100 整除), 但 2000 年是闰年 (能直接被 400 整除).
\begin{awkcode}
    function daynum(y, m, d,    days, i, n) {   # 1 == Jan 1, 1901
        split("31 28 31 30 31 30 31 31 30 31 30 31", days)
        # 365 days a year, plus one for each leap year
        n = (y-1901) * 365 + int((y-1901)/4)
        if (y % 4 == 0) # leap year from 1901 to 2099
            days[2]++
        for (i = 1; i < m; i++)
            n += days[i]
        return n + d
    }
        { print daynum($1, $2, $3) }
\end{awkcode}
这个程序只对 1901 年到 2099 年之间的年份才是正确的, 而且它也不检查输入
数据的有效性.

\exer\ref{exer:numtowords} 修改 \texttt{numtowords} 的一种方式是:
\begin{awkcode}
    function numtowords(n,   cents, dols, s) { # n has 2 decimal places
        cents = substr(n, length(n)-1, 2)
        dols = substr(n, 1, length(n)-3)
        if (dols ==  0)
            s = "zero dollars and " cents " cents exactly"
        else
            s = intowords(dols) " dollars and " cents " cents exactly"
        sub(/^one dollars/, "one dollar", s)
        gsub(/  +/, " ", s)
        return s
\end{awkcode}
函数 \texttt{sub} 可以修复 ``one dollars'' 问题, \texttt{gsub} 可以移除
多余的空格, 即使原文本来就没错, 这两条语句也不会造成什么影响, 这比先
判断再更改要容易得多.
\marginpar{195}
