% vim: ts=4 sts=4 sw=4 et tw=75

\chapter{Awk 语言}
\label{chap:the_awk_language}

\marginpar{21}
这一章解释---大部分都带有例子---构成一个 awk 程序的构造要素. 由于这次要描述
的是整个语言, 所以材料会非常琐细, 所以我们建议读者只需要浏览一下即可, 当
有必要的时候再回来查看细节.

最简单的 awk 程序是一个由多个 \patact 构成的序列:
\begin{pattern}
\textit{pattern} \texttt{\{} \textit{action} \texttt{\}} \par
\textit{pattern} \texttt{\{} \textit{action} \texttt{\}} \par
...
\end{pattern}
在某些语句中, 模式可以不存在; 还有些语句, 动作及其包围它的花括号也可以不存
在. 如果你的程序经过 awk 检查后没有发现语法错误, 它就会每次读取一个输入行,
对读取到的每一行, 按顺序检查每一个模式. 对每一个与当前行匹配的模式, 对应
的动作就会被执行. 一个缺失的模式匹配每一个输入行, 因此每一个不带有模式的动
作对每一个输入行都会执行. 只含有模式而没有动作的语句, 会打印每一个匹配模式
的输入行. 大部分情况下, 在这一章出现的术语 ``输入行'' 与 ``记录'' 被当作
一对同义词. 在 \ref{sec:input} 节, 我们都会讨论多行记录, 多行记录指的是一
个记录包含了多个行.

这一章的第一节会详细描述模式. 第二节通过描述表达式, 赋值语句与流程控制语句,
展开对动作的讨论. 剩下的小节包括函数定义, 输出, 输入, 以及 awk 如果调用其
他程序. 大部分小节都包含对主要性质的总结.

\subsection{输入文件\filename{countries}}
\label{subsec:the_input_file_countries}

作为本章许多 awk 程序的输入数据, 我们将使用文件 \filename{countries}. 每一
行都包括一个国家的名字, 面积 (以千平方英里为单位), 人口 (以百万为单位), 以
及这个国家所在的大陆. 数据来源于 1984 年, 苏联被归到了亚洲. 在文件里, 四列
数据用制表符分隔; 用一个空白符分隔 \texttt{North} (\texttt{South}) 与
\texttt{America}.

文件 \filename{countries} 包含下面几行:
\marginpar{22}
\begin{file}
    USSR        8649    275     Asia
    Canada      3852    25      North America
    China       3705    1032    Asia
    USA         3615    237     North America
    Brazil      3286    134     South America
    India       1267    746     Asia
    Mexico      762     78      North America
    France      211     55      Europe
    Japan       144     120     Asia
    Germany     96      61      Europe
    England     94      56      Europe
\end{file}

在这一章的剩下部分, 如果没有显式给出输入数据, 默认将 \filename{countries}
作为输入数据.

\subsection{程序格式}
\label{subsec:program_format}

\patact 语句, 以及动作内的语句通常用换行符分隔, 但是若干条语句也可出现在同
一行, 只要它们之间用分号分开即可. 一个分号可以放在任何语句的末尾.

动作的左花括号必须与它的模式在同一行; 而剩下的部分, 包括右花括号, 则可以出
现在下面几行.

空行会被忽略; 它们可在插入在语句之前或之后, 用来提高程序的可读性. 空格与制
表符可以出现在运算符与操作数的周围, 同样也是为了提高可读性.

注释可以出现在任意一行的末尾. 一个注释以井号开始, 以换行符结束, 正如
\begin{awkcode}
    { print $1, $3 }    # print country name and population
\end{awkcode}

一条长语句可以分散成多行, 只要在断行处插入一个反斜杆即可:
\begin{awkcode}
    { print \
            $1,     # country name
            $2,     # area in thousands of square miles
            $3 }    # population in millions
\end{awkcode}
正如这个例子所呈现的那样, 语句可以在逗号之后断行, 并且注释可以插入在断行的
末尾.

在这本书里我们用到了若干种格式化风格, 之所以这样做, 一方面是为了比较不同的
风格之间的差异, 另一方面是为了避免程序占用过多的行. 对于比较短小的程序,
就像本章中出现过那些例子, 格式并不是非常重要, 但是一致性与可读性对于大程序
的管理非常有帮助.

\section{模式}
\label{sec:patterns}
\marginpar{23}

模式控制动作的执行. 这一小节描述模式的6种类型, 以及匹配它们的条件.
\begin{summary}{模式汇总}
    \begin{enumerate}
        \item \BEGIN \verb'{' \stmt \verb'}'
            在输入被读取之后, \stmt 被执行一次.
        \item \END \verb'{' \stmt \verb'}'
            当所以输入被读取完毕之后, \stmt 被执行一次.
        \item \expr \verb'{' \stmt \verb'}'
            每碰到一个使 \expr 为真的输入行, \stmt 就被执行. \expr 为真指
            的是其值非零或非空.
        \item \verb'/'\regexpr\verb'/' \verb'{'
            \stmt \verb'}'
            当碰到这样一个输入行时, \stmt 就被执行: 输入行含有一段字符串,
            而该字符串可以被 \regexpr 匹配.
        \item \textit{compound pattern} \verb'{' \stmt \verb'}'
            一个复合模式将表达式用 \AND (AND), \OR (OR), \NOT (NOT), 以及
            括号组合起来; 当 \textit{compound pattern} 为真时, \stmt 执行.
        \item \pat$_1$\verb',' \pat$_2$ \verb'{' \stmt \verb'}'
            一个范围模式匹配多个输入行, 这些输入行从匹配 \pat$_1$ 的行开始,
            到匹配 \pat$_2$ 的行结束, 包括这两行; 对这其中的每一行执行
            \stmt.
    \end{enumerate}
    \BEGIN 与 \END 不与其他模式组合. 一个范围模式不能是其他模式的一部分.
    \BEGIN 与 \END 是唯一两个不能省略动作的模式.
\end{summary}

\subsection{\BEGIN 与 \END}
\label{subsec:begin_and_end}

\BEGIN 与 \END 这两个模式匹配任何输入行. 实际情况是, 当 awk 从输入读取数据
之前, \BEGIN 里的语句被执行; 当所有输入数据被读取完毕, \END 里的语句被执行.
于是, \BEGIN 与 \END 分别提供了一种控制初始化与扫尾的方式. \BEGIN 与 \END
不能与其他模式作组合. 如果有多个 \BEGIN, 与其关联的动作会按照它们在程序中
出现的顺序执行, 这种行为对多个 \END 同样适用. 我们通常将 \BEGIN 放在程序
开关, 将 \END 放在程序末尾, 虽然这并不是强制的.

\BEGIN 的一个常用用途是更改输入行被分割为字段的默认方式. 分割字符由一个内
建变量 \fs 控制. 默认情况下字段由空格或 (和) 制表符分割, 此时 \fs 的值被
\marginpar{24}
设置为一个空格符. 将 \fs 设置为一个不是空格的字符, 就会使该字符成为字段分
割符.

下面这个程序在 \BEGIN 的动作里将字段字割符设置为制表符 (\verb'\t'), 并在
输出之前打印标题. 第二个 \printf 语句 (对每一个输入行它都会被执行) 将输出
格式化成一个表格, 使得每一列都刚好与标题的列表头对齐. \END 打印总和. (变量
与表达式在 \ref{sec:actions} 节讨论.
\begin{awkcode}
    # print countries with column headers and totals

    BEGIN { FS = "\t"   # make tab the field separator
            printf("%10s %6s %5s   %s\n\n",
                  "COUNTRY", "AREA", "POP", "CONTINENT")
          }
          { printf("%10s %6d %5d   %s\n", $1, $2, $3, $4)
            area = area + $2
            pop = pop + $3
          }
    END   { printf("\n%10s %6d %5d\n", "TOTAL", area, pop) }
\end{awkcode}
如果将 \filename{countries} 作为输入, 将出将是
\begin{file}
   COUNTRY   AREA   POP   CONTINENT

      USSR   8649   275   Asia
    Canada   3852    25   North America
     China   3705  1032   Asia
       USA   3615   237   North America
    Brazil   3286   134   South America
     India   1267   746   Asia
    Mexico    762    78   North America
    France    211    55   Europe
     Japan    144   120   Asia
   Germany     96    61   Europe
   England     94    56   Europe

     TOTAL  25681  2819
\end{file}

\subsection{用表达式作为模式}
\label{subsec:expressions_as_patterns}

就像大多数程序设计语言一样, awk 有着非常丰富的用来描述数值计算的表达式.
但是与许多语言不同的是, awk 还有用于描述字符串操作的表达式. 在整本书里,
\textit{string} 都表示一个由 0 个或多个字符组成的序列. 这些字符串可以存储
在变量中, 也可以以字符串常量的形式出现, 就像 \verb'""' 或 \verb'Asia'. 字
符串 \verb'""' 不包括任何字符, 叫做 \cterm{空字符串} (\term{null string}).
术语 \cterm{子字符串} (\term{substring}) 表示一个字符内部的, 由0个或多个
字符组成的连续序列. 对任意一个字符串, 空字符串都可以看作是该字符串第一个字
符之前的, 长度为0的子字符串, 或者是一对相邻字符之间的子字符串, 又或者是
最后一个字符之后的子字符串.

任意一个表达式都可以用作任意运算符的操作数. 如果一个表达式拥有一个数值形式
\marginpar{25}
的值, 而运算符要求一个字符串值, 那么该数值会自动转换成字符串, 类似地, 当
运算符要求一个数值时, 字符串被自动转换成数值.

任意一个表达式都可以当作模式来使用. 如果一个作为模式使用的表达式, 对当前
输入行的求值结果不空或非零, 那么该模式就匹配该行. 典型的表达式模式是那些
涉及到数值或字符串比较的表达式. 一个比较表达式包含 6 种关系运算符中的一种,
或者包含两种字符串匹配运算符中的一种: \verb'~' 与 \verb'!~' 在下一小节讨论.
这些运算列在表 \ref{tbl:comparison_operators} 中.
\caption{比较运算符}
\label{tbl:comparison_operators}
\begin{tabular}{c|c}
    \hline
    \hline
    运算符      & 意义 \\
    \verb'<'    & 小于 \\
    \verb'<='   & 小于或等于 \\
    \verb'=='   & 等于  \\
    \verb'!='   & 不等于 \\
    \verb'>='   & 大于或等于 \\
    \verb'>'    & 大于  \\
    \verb'~'    & 匹配 \\
    \verb'!~'   & 不匹配
\end{tabular}

如果模式是一个比较表达式, 就像 \verb'NF > 10', 当当前行使该条件满足时, 这
个模式就算是匹配该输入行, 在这里条件满足指的是当前输入行的字段数大于 10.
如果模式是一个算术表达式, 就像 \nf, 如果该表达式的值非零, 那么当前输入行被
匹配. 如果模式是一个字符串表达式, 当表达式的字符串值非空时, 当前输入行被
匹配.

在一个关系比较中, 如果两个操作数都是数值, 关系比较将会按照数值比较进行;
否则的话, 数值操作数会被转换成字符串, 再将操作数按字符串的形式进行比较.
两个字符串间的比较按照字符逐个相比, 字符间的先后顺序依赖于机器提供的字符
集 (大多数情况下是 ASCII 字符集). 一个字符串 ``小于'' 另一个, 如果它比另
一个字符串更早出现的话, 例如 \verb'"Canada" < "China"',
\verb'"Asia" < "Asian"'.

模式
\begin{awkcode}
    $3/$2 >= 0.5
\end{awkcode}
选择那些第3个字段除以第2个字段的商大于0.5的输入行, 而
\begin{awkcode}
    $0 >= "M"
\end{awkcode}
\marginpar{26}
选择那些以字母 \verb'M', \verb'N', \verb'O' 等开头的输入行:
\begin{file}
    USSR	8649	275	Asia
    USA	3615	237	North America
    Mexico	762	78	North America
\end{file}

有时候一个比较运算符的类型不能单单靠表达式表现出来的语法形式来判断. 程序
\begin{awkcode}
    $1 < $4
\end{awkcode}
可以以数值的形式, 或者字符串的形式比较输入行的第1个与第4个字段. 在这里,
比较的类型取决于字段的值, 并且有可能每一行都有不同的情况出现. 文件
\filename{countries} 的第1与第4个字段总是字符串, 所以比较总是以字符串的形
式进行; 输出是
\begin{file}
    Canada	3852	25	North America
    Brazil	3286	134	South America
    Mexico	762	78	North America
    England	94	56	Europe
\end{file}
只有当两个字段都是数值时, 比较才会以数值的形式进行; 这种情况可以是
\begin{awkcode}
    $2 < $3
\end{awkcode}

\ref{sec:actions} 节包含了一个更加完整的, 关于字符串, 数值与表达式的讨论.

\subsection{字符串匹配 模式}
\label{subsec:string_matching_pattern}

Awk 提供了一种称为 \cterm{正则表达式} (\regexpr) 表示法, 它可以用来指定和
匹配一个字符串.  正则表达式 在 Unix 中使用得非常普遍, 包括文本编译器与
shell. 受限形式的正则表达式也出现在其他系统中, 在 MS-DOS 中可以用
``通配符'' 指定一个文件名集合.

一个 \cterm{字符串匹配模式} (\term{string-matching pattern}
测试一个字符串是否包含一段可以被正则表达式匹配的子字符串.

最简单的正则表达式是仅由数字与字母组成的字符串, 就像 \verb'Asia', 它匹配的
就是它自己. 为了将一个正则表达式切换成一个模式, 只需要用一对斜杆包围起来即
可:
\begin{awkcode}
    /Asia/
\end{awkcode}
这个模式匹配那些含有子字符串 \verb'Asia' 的输入行, 例如 \verb'Asia',
\verb'Asian', 或 \verb'Pan-Asiatic'. 注意, 正则表达式中空格是有意义的: 字
符串匹配模式
\marginpar{27}
\begin{summary}{字符串匹配模式}
    \begin{enumerate}
        \item \verb'/'\textit{regexpr}\verb'/' \\
            当当前输入行包含一段能够被 \textit{regexpr} 匹配的子字符串时,
            该模式被匹配.
        \item \regexpr \verb'~' \verb'/'\textit{regexpr}\verb'/' \\
            如果 \expr 的字符串值包含一段能够被 \textit{regexpr} 匹配的子
            字符时, 该模式被匹配.
        \item \expr \verb'!~' \verb'/'\textit{regexpr}\verb'/' \\
            如果 \expr 的字符串值不包含能够被 \textit{regexpr} 匹配的子字
            符串, 该模式被匹配.
    \end{enumerate}
    在 \verb'~' 与 \verb'!~' 的语境中, 任意一个表达式都可以出现在
    \verb'/'\textit{regexpr}\verb'/' 出现的地方.
\end{summary}

\begin{awkcode}
    / Asia /
\end{awkcode}
只有当 \verb'Asia' 被一对空格包围时才会被匹配.

上面的模式是三种字符串匹配模式当中的一种. 它的形式是用一对斜杆将正则表达式
包围起来:
\begin{pattern}
    \verb'/'\textit{r}\verb'/'
\end{pattern}
这个模式匹配那些含有能够被 \textit{r} 匹配的子字符串的输入行.

剩下的两种字符串匹配模式使用到了显式的匹配运算符:
\begin{pattern}
    \expr \verb'~' \verb'/'\textit{r}\verb'/' \\
    \expr \verb'!~' \verb'/'\textit{r}\verb'/'
\end{pattern}
匹配运算符 \verb'~' 的意思是 ``被...匹配'', \verb'!~' 的意思是 ``不被...%
匹配''. 当 \expr 的字符串值包含一段能够被正则表达式 \textit{r} 匹配的子字
串时, 第一个模式被匹配; 当不存在这样的子字符串时, 第二个模式被匹配.

匹配运算符的左操作数经常是一个字段: 模式
\begin{awkcode}
    $4 ~ /Asia/
\end{awkcode}
匹配所有{}第4个字段包含 \verb'Asia' 的输入行, 而
\begin{awkcode}
    $4 !~ /Asia/
\end{awkcode}
匹配所有{}第4个字段\cterm{不}包含 \verb'Asia' 的输入行.

注意到, 字符串匹配模式
\begin{awkcode}
    /Asia/
\end{awkcode}
是
\begin{awkcode}
    $0 ~ /Asia/
\end{awkcode}
的简写形式.

\subsection{正则表达式}
\label{subsec:regular_expressions}
\marginpar{28}
正则表达式是一种用于指定和匹配字符串的表示法. 就像算术表达式一样,
一个正则表达式是一个基本表达式, 或者是多个子表达式通过运算符组合而成.
为了理解被一个正则表达式匹配的字符串, 我们需要先了解被子表达式匹配的字符串.
\begin{summary}{正则表达式}
\begin{enumerate}
\item 正则表达式的元字符包括: \\
    \verb'\ ^ $ . [ ] | ( ) * + ?'
\item 一个基本的表达式包括下面几种: \\
    一个不是元字符的字符, 例如 \verb'A', 这个正则表达式匹配的就是它本身. \\
    一个匹配特殊符号的转义字符: \verb'\t' 匹配一个制表符 (见表
    \ref{tbl:escape_sequence}). \\
    一个被引述的元字符, 例如 \verb'\*', 按字面意义匹配元字符. \\
    \verb'^' 匹配一行的开始. \\
    \verb'$' 匹配一行的结束. \\
    \verb'.' 匹配任意一个字符. \\
    一个字符集合: \verb'[ABC]' 匹配字符 \verb'A', \verb'B' 或 \verb'C'. \\
    字符集合可能包含缩写形式: \verb'[A-Za-z]' 匹配单个字母. \\
    一个互补的字母集合: \verb'[^0-9]' 匹配任意一个字符, 但是除了数字.
\item 这些运算符将正则表达式组合起来:
    选择: \verb'A|B' 匹配 \verb'A' 或 \verb'B'. \\
    连接: \verb'AB' 匹配后面紧跟着 \verb'B' 的 \verb'A'. \\
    闭包: \verb'A*' 匹配0个或多个 \verb'A'. \\
    正闭包: \verb'A+' 匹配一个或多个 \verb'A'. \\
    零或一: \verb'A?' 匹配空字符串或 \verb'A'. \\
    括号: \verb'('\textit{r}\verb')' 匹配与 \textit{r} 相同的字符串.
\end{enumerate}
\end{summary}

基本的正则表达式在上面的表格中列出. 字符
\begin{file}
    \ ^ $ . [ ] | ( ) * + ?
\end{file}
叫作 \cterm{元字符} (\term{metacharacter}), 之所以这样称呼是因为它们具有
特殊的意义. 一个由单个非元字符构成的正则表达式匹配它自身. 于是, 一个字母
或一个数字都算作是一个基本的正则表达式, 与自身相匹配.  为了在正则表达式中
保留元字符的字面意义, 需要在字符的前面加上反斜杆. 于是, \verb'\$' 匹配
普通字符 \verb'$'. 如果某个字符前面冠有 \verb'\', 我们就说该字符是被
\cterm{引述} (\term{quoted}) 的.

在一个正则表达式中, 一个未被引述的脱字符 \verb'^' 表示一行的开始, 一个
未被引述的美元符 \verb'$' 匹配一行的结束, 一个未被引述的句点 \verb'.' 匹配
匹配任意一个字符. 于是,
\begin{tabbing}
    \verb'^C' \hspace{4em}  \= 匹配以字符 \verb'C' 开始的字符串; \\
    \verb'C$'   \> 匹配以字符 \verb'C' 结束的字符串; \\
    \verb'^C$'  \> 匹配只含有单个字符 \verb'C' 的字符串; \\
    \verb'^.$'  \> 匹配有且仅有一个字符的字符串; \\
    \verb'^...$ \> 匹配有且仅有3个字符的字符串; \\
    \verb'...'  \> 匹配任意3个字符; \\
    \verb'\.$'  \> 匹配以句点结束的字符串.
\end{tabbing}
\marginpar{29}

由一组被包围在方括号中的字符组成的正则表达式称为 \cterm{字符集合}
(\term{character class}); 这个表达式匹配字符集合中的任意一个字符. 例如,
\verb'[AEIOU]' 匹配 \verb'A', \verb'E', \verb'I', \verb'O' 或 \verb'U'.

使用连字符的字符集合可以表示一段字符范围. 紧跟在连字符左边的字符定义了范围
的开始, 紧跟在连字符右边的字符定义了范围的结束. 于是, \verb'[0-9]' 匹配
任意一个数字, \verb'[a-zA-Z][0-9]' 匹配一个后面跟着一个数字的字母. 如果
左右两边都没有操作数, 那么字符集合中的连字符就表示它本身, 所以 \verb'[+-]'
与 \verb'[-+]' 匹配一个 \verb'+' 或 \verb'-'. \verb'[A-Za-z-]' 匹配一个
含有连字符的单词.

一个 \cterm{互补} (\term{complemented}) 的字符集合在 \verb'[' 之后以
\verb'^' 开始. 这样一个集合匹配任意一个不在集合中的字符, 集合中的字符指的
是方括号内排在脱字符之后的那些字符. 于是, \verb'[^0-9]' 匹配任意一个不是
数字的字符; \verb'[^a-zA-Z]' 匹配任意一个不是字母的字符.
\begin{tabbing}
    \verb'^[ABC]' \hspace{4em}  \= 匹配以 \verb'A', \verb'B', 或 \verb'C'
        开始的字符串; \\
    \verb'^[^ABC]' \> 匹配以任意一个字符 (除了 \verb'A', \verb'B',
        或 \verb'C') \> 开始的字符串; \\
    \verb'[^ABC] \> 匹配任意一个字符, 除了 \verb'A', \verb'B', 或
        \verb'C'; \\
    \verb'^[^a-z]' \> 匹配任意一个有且仅有一个字符的字符串, 且该字
        符不能是小写字母.
\end{tabbing}

在一个字母集合内, 所有的字符都具有它自身的字面意义, 除了引述字符 \verb'/',
开始的 \verb'^', 以及两个字符间的 \verb'-'. 于是, \verb'[.]' 匹配一个句
点, \verb'^[^^]' 匹配不以脱字符开始的字符串.

可以使用括号来指定正则表达式中的各个成分如何组合. 有两种二元正则表达式运算
符: 选择与连接. 选择运算符 \verb'|' 用来指定一个选择: 如果 \textit{r}$_1$
与 \textit{r}$_2$ 是正则表达式, 那么 \textit{r}$_1$\verb'|'\textit{r}$_2$
所匹配的字符串, 或者与 \textit{r}$_1$, 或者与 \textit{r}$_2$ 匹配.

Awk 不存在显式的连接运算符. 如果 \textit{r}$_1$ 与 \textit{r}$_2$ 是正则
表达式, 那么 \verb'('\textit{r}$_1$\verb')'\verb'('\textit{r}$_1$\verb')'
(在 \verb'('\textit{r}$_1$\verb')' 与 \verb'('\textit{r}$_2$\verb')' 之
间没有空格) 所匹配的字符串具有形式 \textit{xy}, 其中 \textit{x} 被
\textit{r}$_1$ 匹配, \textit{y} 被 \textit{r}$_2$ 匹配. \textit{r}$_1$ 或
\textit{r}$_2$ 两边的括号可以省略, 如果被括号包围的正则表达式不包含选择
运算符的话. 正则表达式
\begin{awkcode}
    (Asian|European|North American) (male|female) (black|blue)bird
\end{awkcode}
一共匹配12个字符串, 从
\begin{file}
    Asian male blackbird
\end{file}
到
\marginpar{30}
\begin{file}
    North American female bluebird
\end{file}

符号 \verb'*', \verb'+' 与 \verb'?' 是一元运算符, 用来指定正则表达式的
重复次数. 如果 \textit{r} 是一个正则表达式, 那么
\verb'('\textit{r}\verb')'\verb'*' 所匹配的字符串含有零个或连续的多个,
能被 \textit{r} 匹配的子符串. \textit{r}\verb'?' 匹配的字符串, 要么是空字
符串, 要么是能够被 \textit{r} 匹配的字符串. 如果 \textit{r} 是一个基本的
正则表达式, 那么括号可以省略.
\begin{tabbing}
    \verb'B*' \hspace{4em} \= 匹配空字符串, 或 \verb'B', \verb'BB', 等等.\\
    \verb'AB*C' \> 匹配 \verb'AC', 或 \verb'ABC', \verb'ABBC', 等等. \\
    \verb'AB+C' \> 匹配 \verb'ABC', 或 \verb'ABBC', \verb'ABBBC', 等等.\\
    \verb'AB?C' \> 匹配 \verb'AC' 或 \verb'ABC' \\
    \verb'[A-Z]+' \> 匹配由一个或多个大写字母组成的字符串. \\
    \verb'(AB)+C' \> 匹配 \verb'ABC', \verb'ABABC', \verb'ABABABC', 等等.
\end{tabbing}

在正则表达式中, 选择运算符 \verb'|' 的优先级最低, 然后是连接运算, 最后是重
复运算符 \verb'*', \verb'+', 与 \verb'?'. 与算术表达式的规则一样, 优先
级高的运算符优先处理. 这种规则经常使得括号被省略: \verb'ab|cd' 等价于
\verb'(ab)|(cd)', \verb'^ab|cd*e$' 等价于 \verb'(^ab)|(c(d*)e$)'.

为了结束关于正则表达式的讨论, 这里列出了一些比较有用的字符串匹配模式的
例子, 这些例子都带有使用了一元与二元运算符的正则表达式, 同时还描述了能够
被该模式匹配的输入行. 回想一下, 如果当前输入行含有至少一个, 能够被
\textit{r} 匹配的子字符串, 那么字符串匹配模式 \verb'/'\textit{r}\verb'/'
匹配成功.
\begin{enumerate}
\item \verb'^[0-9]+$/' \\
    匹配含有且只含有数字的输入行.
\item \verb'^[0-9][0-9][0-9]$/' \\
    输入行有且仅有3个数字.
\item \verb'^(\+|-)?[0-9]+\.?[0-9]*$/' \\
    十进制小数, 符号与小数部分是可选的.
\item \verb'^[+-]?[0-9]+[.]?[0-9]*$/' \\
    也是匹配十进制小数, 带有可选的符号与小数部分.
\item \verb'^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$/' \\
    浮点数, 符号与指数部分是可选的.
\item \verb'^[A-Za-z][A-Za-z0-9]*$/' \\
    一个字母, 后面再跟着任意多个字母或数字 (比如 awk 的变量名).
\item \verb'^[A-Za-z]$|^[A-Za-z][0-9]$/' \\
    一个字母, 又或者是一个后面跟着一个数字的字母 (比如 Basic 的变量名).
\item \verb'^[A-Za-z][0-9]?$/' \\
    同样是一个字母, 又或者是一个后面跟着一个数字的字母.
\end{enumerate}

在第3个例子中, 为了匹配元字符\verb'+' 与 \verb'-' 的字面值, 必须在它们的
前面加上反斜线, 而在字符集合中则不需要, 所以第 3 项与 第 4 项的功能是等价
的.
\marginpar{31}

任意一个被一对斜线包围的正则表达式都可以作为匹配运算符的右操作数: 程序
\begin{awkcode}
    $2 !~ /^[0-9]+$/
\end{awkcode}
打印那些第2个字段不全是数字的行.

在正则表达式与字符串内部, awk 使用一个特定的字符序列--\cterm{转义序列}
(\term{escape sequences})--来表示那些无法用方式表示的字符. 例如, \verb'\n'
表示一个换行符, 它无法以其他方式出现在字符串或正则表达式中; \verb'\b' 表示
退格符; \verb'\t' 表示制表符; \verb'007' 表示 ASCII 中的响铃符; \verb'\/'
表示一个斜杆. 转义序列在 awk 程序中才会有特殊的意义; 如果在数据中, 它们则
是普通的字符. 完整的转义序列名单在表 \ref{tbl:escape_sequences}.
\caption{转义序列}
\label{tbl:escape_sequences}
\begin{tabular}{c|c}
    \hline
    \hline
    序列        & 意义 \\
    \hline
    \verb'\b'   & 退格  \\
    \verb'\f'   & 换页  \\
    \verb'\n'   & 换行  \\
    \verb'\r'   & 回车  \\
    \verb't'    & 制表符    \\
    \verb'\'\textit{ddd} & 八进制数 \textit{ddd}, \textit{ddd} 含有 1 到 3
        个数字, 每个数字的值在 0 到 7 之间 \\
    \verb'\'\textit{c} & 其他的字面意义上的 \textit{c} (举例来说, \verb'\\'
        表示反斜杆, \verb'\"' 表示双引号)
    \hline
\end{tabular}

表 \ref{tbl:regular_expressions} 总结了正则表达式, 以及它们所匹配的字符串.
运算符按优先级递增的顺序列出.
\caption{tbl:regular_expressions}
\begin{tabular}{c|l}
    \hline
    \hline
    表达式  & 匹配  \\
    \hline
    \textit{c}  & 非元字符 \textit{c}   \\
    \veb'\'\textit{c}   & 转义序列或字面意义上的 \textit{c} \\
    \verb'^'    & 字符串的开始 \\
    \verb'$'    & 字符串的结束  \\
    \verb'.'    & 任意一个字符 \\
    \verb'['\textit{c}$_1$\textit{c}$_2$...\verb']' & 任意一个在
        \textit{c}$_1$\textit{c}$_2$... 中的字符. \\
    \verb'[^'\textit{c}$_1$\textit{c}$_2$...\verb']'    & 任意一个不在
        \textit{c}$_1$\textit{c}$_2$... 中的字符. \\
    \verb'['\textit{c}$_1$\verb'-'\textit{c}$_2$...\verb']' & 任意一个在
        范围内的字符, 范围由 \textit{c}$_1$ 开始, 由 \textit{c}$_2$ 结束.
\verb'[^'\textit{c}$_1$\verb'-'\textit{c}$_2$...\verb']' & 任意一个不在
        范围内的字符, 范围由 \textit{c}$_1$ 开始, 由 \textit{c}$_2$ 结束.
        \\
    \textit{r}$_1$\verb'|'\textit{r}$_2$    & 任意一个被 \textit{r}$_1$
        或 \textit{r}$_2$ 匹配的字符串. \\
\verb'('\textit{r}$_1$\verb')('\textit{r}$_2$\verb')'    &
        任意一个字串 \textit{xy}, 其中 \textit{r}$_1$ 匹配 \textit{x},
        而 \textit{r}$_1$ 匹配 \textit{y}; 如果当中不含有选择运算符, 那么
        括号是可能活力的 \\
        \verb'('\textit{r}\verb')*' & 零个或连续多个能被 \textit{r} 匹配
        的字符串.
        \verb'('\textit{r}\verb')+' & 一个或连续多个能被 \textit{r} 匹配
        的字符串.
        \verb'('\textit{r}\verb')?' & 零个或一个能被 \textit{r} 匹配
        的字符串. 在这里括号可以省略.
        \verb'('\textit{r}\verb')' & 任意一个能被 \textit{r} 匹配
        的字符串.
\end{tabular}

\subsection{复合模式}
\label{subsec:compound_patterns}

一个复合模式是一个组合了其他模式的表达式, 通过括号, 逻辑运算符 \OR{}(OR),
\AND{}(AND), \NOT{}(NOT) 来进行组合. 如果表达式的值为真, 那么复合模式就匹配
当前输入行. 下面这个程序使用 AND 运算符来选择那些第 4 个字段是 \verb'Asia'
且第 3 个字段大于 500 的行:
\marginpar{32}
\begin{awkcode}
    $4 == "Asia" && $3 > 500
\end{awkcode}
程序
\begin{awkcode}
    $4 == "Asia" || $4 == "Europe"
\end{awkcode}
使用 OR 运算符来选择那些第 4 个字段是 \verb'Asia' 或 \verb'Europe' 的行.
因为较后的这个查询是一个针对字符串的测试, 所以该程序的另一种写法是用到了
选择运算符的正则表达式:
\begin{awkcode}
    $4 ~ /^(Asia|Europe)$/
\end{awkcode}
(如果两个正则表达式匹配了同一个字符串, 我们就说这两个正则表达式是
\cterm{等价} (\term{equivalent}) 的. 测试一下你对前面所说的正则表达式的
规则的理解程序, 下面这两个正则表达式等不等价: \verb'^Asia|Europe$' 与
\verb'(Asia|Europe)$' ?)

如果在其他字段中没有出现 \verb'Asia' 或 \verb'Europe', 那么上面的模式也
可以写成
\begin{awkcode}
    /Asia/ || /Europe/
\end{awkcode}
或
\begin{awkcode}
    /Asia|Europe/
\end{awkcode}

运算符 \OR 优先级最低, 再往高是 \AND, 最高的是 \NOT. \AND 与 \OR 从左至
右计算操作数的值, 一旦已经知道整个表达式的值, 计算便停止.

\subsection{范围模式}
\label{subsec:range_patterns}

一个范围模式由两个被逗号分开的模式组成, 正如
\begin{pattern}
    \textit{pat}$_1$\verb',' \textit{pat}$_2$
\end{pattern}
一个范围模式匹配多个输入行, 这些输入行从匹配 \textit{pat}$_1$ 的行开始,
到匹配 \textit{pat}$_2$ 的行结束, 包括这两行; \textit{pat}$_2$ 可以与
\textit{pat}$_1$ 匹配到同一行, 这时候模式的范围大小就退化到了一行. 作为
一个例子, 模式
\begin{awkcode}
    /Canada/, /USA/
\end{awkcode}
匹配的行从包含 \texttt{Canada} 的行开始, 到包含 \texttt{USA} 的行结束.

一旦范围的第一个模式匹配到了某个输入行, 那么整个范围模式的匹配就开始了;
\marginpar{33}
如果范围模式的第二个模式一直都没有匹配到某个输入行, 那么范围模式会一直
匹配到输入结束:
\begin{awkcode}
    /Europe/, /Africa/
\end{awkcode}
输出
\begin{file}
France	211	55	Europe
Japan	144	120	Asia
Germany	96	61	Europe
England	94	56	Europe
\end{file}

在下一个例子里, 变量 \verb'FNR' 表示从当前输入文件中, 到目前为止读取到的
行数, 变量 \verb'FILENAME' 表示当前输入文件名; 它们两个都是内建变量. 于是,
程序
\begin{awkcode}
    FNR == 1, FNR == 5 { print FILENAME ": " $0 }
\end{awkcode}
打印每一个输入文件的前5行, 并在每一行行加上文件名. 这个程序也可以写成下面
这种形式:
\begin{awkcode}
    FNR <= 5 { print FILENAME ": " $0 }
\end{awkcode}

一个范围模式不能是其他模式的一部分.

\subsection{模式总结}
\label{subsec:summary_of_patterns}

表 \ref{tbl:patterns} 总结了可以出现在 \patact 语句中的模式种类.
\begin{center}
\caption{模式}
\label{tbl:patterns}
\begin{tabular}{c|c|l}
    \hline
    \hline
    模式        & 例子      & 匹配  \\
    \hline
    \BEGIN      & \BEGIN    & 输入被读取之前 \\
    \END        & \END      & 所有输入被读取完之后 \\
    \expr       & \verb'$3 < 100' & 第3个字段小于100的行 \\
    \textit{string-matching} & \verb'/Asia/' & 含有 \verb'Asia' 的行 \\
    \textit{compound}   & \verb'$3 < 100 && $4 == "Asia"' & 第3个字段小于
        100 并且 第 4 个字段含有  \verb'Asia' 的行 \\
    \textit{range} & \verb'NR==10, NR==20' & 输入的第10行到第20行.
    \hline
\end{tabular}{c|c|l}
\end{center}

\section{动作}
\label{sec:actions}
\marginpar{34}

在一个 \patact 语句中, 模式决定动作什么执行. 有时候动作会非常简单: 一条
单独的打印语句或赋值语句. 在有些时候, 动作有可能是多条语句, 语句之间用换
行符或分号分开. 这一小节通过讨论表达式与流程控制语句来开始对动作的描述.
\begin{summary}
    动作中的语句可以包括:
    \expr, 包括常量, 变量, 赋值, 函数调用等待.
    \print \textit{expression-list}
    \printf\verb'('\fmt\verb', '\textit{expression-list}\verb')'
    \verb'if ('\expr\verb')' \stmt
    \verb'if ('\expr\verb')' \stmt \verb'else '\stmt
    \verb'while ('\expr\verb') '\stmt
    \verb'for ('\expr\verb'; '\expr\verb'; '\expr\verb') '\stmt
    \verb'for ('\expr\verb' in '\textit{array}\verb')' \stmt
    \verb'do '\stmt \verb'while ('\expr\verb')'
    \break
    \ctn
\end{summary}

\subsection{表达式}
\label{subsec:expressions}

我们从表达式开始讨论, 因为表达式是最简单的语句, 大多数其他语句都是由不同类
型的表达式组合而成. 主表达式与其他表达式通过运算符组合在一直, 形成一个
表达式. 主表达式是最原始的构造块: 它们包括常量, 变量, 数组引用, 函数调用,
以及各种内建变量, 例如字段的名字.

我们从常量与变量开始对表达式的讨论. 然后是运算符, 它可以用来组合表达式.
这些表达式可以分成 5 种类别: 算术, 比较, 逻辑, 条件, 与赋值. 运算符之后,
讨论的是内建算术运算与字符串函数, 最后是数组.

\emph{常量} (\emph{常量}). Awk 中只有两种类型的常量: 字符串与数值. 将一个
字符序列用一对双引号包围起来就创建了一个字符串常量, 正如 \verb'"Asia"',
\marginpar{35}
或 \verb'"hello, world"' 或 \verb'""'. 字符串常量可以包含表
\ref{tbl:escape_sequence} 列出的转义序列.

一个数值常量可以是一个整数, 就像 \verb'1127', 或十进制小数, \verb'3.14',
或者是用科学计数法表示的数: \verb'0.707E-1'. 同一个数的不同表示法都拥有
相同的值: \verb'1e6', \verb'1.00E6', \verb'10e5', \verb'0.1e7' 与
\verb'1000000' 都表示同一个数. 所有的数都用浮点格式存储, 浮点数的精度依赖
于机器.

\emph{变量} (\emph{Variables}). 表达式可以包含若干种类型的变量: 用户定义的,
内建的, 字段. 用户定义的变量的名字由数字, 字母与下划线构成, 但是名字不能
以数字开始. 所有的内建变量的名字都是大写字母.

每一个变量都有一个值, 这个值可以是字符串或数值, 或两者都是. 因为变量的类型
不需要事先声明, 所以 awk 需要从上下文环境中推断变量的类型. 当需要时, awk 可
以把字符串转化为数值, 或反之. 例如, 在程序
\begin{awkcode}
	$4 == "Asia" { print $1, 100 * $2 }
\end{awkcode}
里, \verb'$2' 会被转换成数值, 如果它原来不是的话, 同样的道理, 如果 \verb'$1'
与 \verb'$4' 原来是字符串的话, 它们会被转换成字符串.

一个未初始化的变量的值是 \verb'""' (空字符串) 与 0.

\emph{内建变量} (\emph{Built-In Variables}. 表 \ref{tbl:built_in_variables}
列出的所有的内建变量. 其中一些我们已经见过了, 另一些会在本节或后面的章节里
用到. 这些变量可以用在所有的表达式中, 而且可以被用户重置. 每当有一个新的文件
被读取, \verb'FILENAME' 就会被重新赋值. 每当有一个新的记录被读进来,
\verb'FNR', \verb'NF', \verb'NR' 就会被重新赋值. 另外, 当 \verb'$0' 发生
改变, 或有新的字段被创建时, \verb'NF' 就被重置. \verb'RLENGTH' 与
\verb'RSTART' 会随着每一次 \verb'match' 的调用而改变.

\begin{figure}[ht]
\caption{tbl:built_in_variables}
\begin{center}
\begin{tabular}{l|l|c}
	\hline
	\hline
	变量	& 意义	& 默认值 \\
	\verb'ARGC'	& 命令行参数的个数	& - \\
	\verb'ARGV'	& 命令行参数数组	& - \\
	\verb'FILENAME'	& 当前输入文件名	& - \\
	\verb'FNR'	& 当前输入文件的记录个数& - \\
	\verb'FS'	& 控制着输入行的字段分割符 & " " \\
	\verb'NF'	& 当前记录的字段个数	& - \\
	\verb'NR'	& 到目前为止读的记录数量 & - \\
	\verb'OFMT	& 数值的输出格式	& "%.6g" \\
	\verb'OFS'	& 输出字段分割符	& " " \\
	\verb'ORS'	& 输出的记录的分割符	& "\n"	\\
	\verb'RLENGTH'	& 被函数 \verb'match' 匹配的字符串的长度 & - \\
	\verb'RS'	& 控制着输入行的记录分割符 & "\n"	\\
	\verb'RSTART'	& 被函数 \verb'match' 匹配的字符串的开始 \\
	\verb'SUBSEP'	& 下标分割符	& \verb'"\034"'	\\
	\hline
\end{tabular}
\end{center}
\end{figure}

\emph{字段变量} (\emph{Field Variables}). 当前输入行的字段从 \verb'$1',
\verb'$2', 一直到 \verb'$NF'; \verb'$0' 表示整行. 字段变量与其他变量相比
没什么不同 --- 它们也可以用在算术或字符串运算中, 也可以被赋值. 于是, 人们
可以将 \filename{countries} 的每一行的第 2 个字段除以 1000, 从而可以用
百万平方英里 --- 而不是千平方英里 --- 来表示面积:
\begin{awkcode}
	{ $2 = $2 / 1000; print }
\end{awkcode}
也可以将一个新的字符串赋值给字段:
\begin{awkcode}
	BEGIN			{ FS = OFS = "\t" }
	$4 == "North America"	{ $4 = "NA" }
	$4 == "South America"	{ $4 = "SA" }
				{ print }
\end{awkcode}
在这个程序里, \BEGIN 动作重新设置 \verb'FS' (\verb'FS' 控制输入行的字段分
割符) 与 \verb'OS' (\verb'OS' 控制输出的字段分割符) 为 制表符. 第 4 行的
\print 语句打印被可能修改过的 \verb'$0'. 值得注意的是: 当 \verb'$0' 被
\marginpar{36}
修改或重新赋值 (同样的情况也可以发生在 \verb'$1', \verb'$2', 等等), \nf
就会被重新计算; 同样的道理, 当 \verb'$1' -- 或 \verb'$2' 等 -- 被修改了,
\verb'$0' 就会被重新构造, 构造的方式是使用 \OFS 重新分割字段.

字段也可以通过表达式指定. 例如, \verb'$(NF-1)' 表示当前输入行的倒数第 2 个
字段. 表达式两边的括号不能省略: \verb'$NF-1' 表示最后一个字段减一后的值.

如果字段变量引用到了不存在的字段, 例如 \verb'$(NF+1), 那么它的值就是初始
值 -- 空字符串. 可以通过向一个字段变量赋值来创建它. 例如, 下面这个程序创建
了第 5 个字段, 该字段包含的值是人口密度:
\begin{awkcode}
    BEGIN { FS = OFS = "\t" }
    { $5 = 1000 * $3 / $2; print }
\end{awkcode}
当需要时, 任何突然出现的字段都会被创建, 并且它们的初始值都是空值.

每一行的字段数都可以不同, 但是 awk 的具体实现通常将字段数上限设置为 100.

\emph{算术运算符} (\emph{Arithmetic Operators}). Awk 提供了通常的 \verb'+',
\verb'-', \verb'*', \verb'/', \verb'%', \verb'^' 运算符. 运算符 \verb'%'
计算余数: \verb'x%y' 的值是 \verb'x' 被 \verb'y' 除的余数; 当 \verb'x' 或
\verb'y' 是负数时, \verb'x%y' 的结果依赖于机器. \verb'^' 是指数运算符:
\verb'x^y' 表示 \verb'x'$^\texttt{y}$. 所有的算术运算都用的是浮点数.

\emph{比较运算符} (\emph{Comparison Operators}). 比较表达式指的是那些含有
关系运算符, 或含有正则表达式匹配运算符的表达式. 关系运算符包括 \verb'<',
\verb'<=', \verb'==' (相等), \verb'!=' (不相等), \verb'>=' 与 \verb'>'.
\marginpar{37}
正则表达式的运算符包括 \verb'~' (被匹配) 与 \verb'!~' (不被匹配).
如果比较表达式的判断结果为真, 则它的值是 1, 否则为 0. 所以, 表达式
\begin{awkcode}
    $4 ~ /Asia/
\end{awkcode}
的值是 1, 如果当前输入行的第 4 个字段包含 \verb'Asia'的话; 反之, 如果不
包含, 那么它的值就是 0.

\emph{逻辑运算符} (\emph{Logical Operators}). 逻辑运算符将多个表达式组合
成为逻辑表达式. 如果逻辑表达式的真值为真, 那么它的值就为 1; 如果为假, 值
就为 0. 在对逻辑表达式求值时, 具有非零值或非空值的操作数被当作真; 相应的,
值为零或空的操作数被当作假. 操作数之间被 \AND  或 \OR 分开, 求值是从左至
右进行的, 当整个逻辑表达式的值可以确定时, 求值就停下来. 这意味着在表达式
\begin{pattern}
    \textit{expr}$_1$ \AND \textit{expr}$_2$
\end{pattern}
中, 如果 \textit{expr}$_1$ 的值为假, 那么 \textit{expr}$_2$ 就不会被求值,
而在表达式
\begin{awkcode}
    \textit{expr}$_3$ \OR \textit{expr}$_4$
\end{awkcode}
中, 如果 \textit{expr}$_3$  的值为真, \textit{expr}$_4$ 就不会被求值.

在 \AND  与 \OR 之后可以插入换行符.

\emph{条件表达式} (\emph{Conditional Expressions}). 一个条件表达式具有形式:
\begin{pattern}
    \textit{expr}$_1$ \verb'?' \textit{expr}$_2$ \verb':' \textit{expr}$_3$
\end{pattern}
首先, \textit{expr}$_1$ 被求值. 如果值为真, 也就是值非零或非空, 那么整个
条件表达式的值就会是 \textit{expr}$_2$ 的值; 否则, 如果 \textit{expr}$_1$
的值为假, 那么条件表达式的值就会是 \textit{expr}$_3$. \textit{expr}$_2$ 与
\marginpar{38}
\textit{expr}$_3$ 只有其中一个会被求值.

下面这个程序利用条件表达式打印 \verb'$1' 的倒数, 如果 \verb'$1' 的值为 0,
那就打印一条警告:
\begin{awkcode}
    { print ($1 != 0 ? 1/$1 : "$1 is zero, line " NR) }
\end{awkcode}

\emph{赋值运算符} (\emph{Assignment Operators}). 在赋值表达式中可以使用 7
种赋值运算符. 最简单的赋值表达式是
\begin{pattern}
    \textit{var} \verb'=' \textit{expr}
\end{pattern}
在这个表达式中, \textit{var} 是一个变量或字段的名字, 然后 \textit{expr} 是
一个任意的表达式. 例如, 为了计算总人口与亚洲的国家数量, 我们可以写
\begin{awkcode}
    $4 == "Asia"    { pop = pop + $3; n = n + 1 }
    END             { print "Total population of the", n,
                            "Asian countries is", pop, "million."
                    }
\end{awkcode}
将 \filename{countries} 作为输入数据, 输出将是
\begin{file}
    Total population of the 4 Asian countries is 2173 million.
\end{file}
第一个动作含有两个赋值语句, 第一个累积人口, 第二个计算国家的数量. 变量没有
被显式地初始化, 但程序仍然按照期望得那样运行, 这是因为每个变量会默认初始为
空字符串 \verb'""' 或数值 0.

在下面这个程序里, 我们仍然利用了默认的初始化行为, 程序的功能是寻找拥有最
多人口的国家:
\begin{awkcode}
    $3 > maxpop { maxpop = $3; country = $1 }
    END         { print "country with largest population:",
                    country, maxpop
                }
\end{awkcode}
注意, 只有当至少有一个 \verb'$3' 是正数时, 程序才是正确的.

另外 6 个赋值运算符是 \verb'+=', \verb'-=', \verb'*=', \verb'/=', \verb'%=',
以及 \verb'^='. 它们的意义都是类似的: \textit{v op}\verb'='\textit{e} 等价
于 \textit{v}\verb'='\textit{v op e}, 但是 \textit{v} 只被求值一次. 赋值
表达式:
\begin{awkcode}
    pop = pop + $3
\end{awkcode}
可以用 \verb'+=' 写成更加紧凑的形式:
\begin{awkcode}
    pop += $3
\end{awkcode}
紧凑形式的表达式与冗长版本具有相同的作用 --- 左值加上右值, 并赋给左值 ---
但是 \verb'+=' 更简短, 运行起来也更快. 再看另外一个例子:
\begin{awkcode}
    { $2 /= 1000; print }
\end{awkcode}
这个程序将第 2 个字段除以 1000, 再打印整行.
\marginpar{39}

一个赋值语句是一个表达式; 整个表达式的值是左边的变量的新值. 于是, 赋值语句
可以放在任意表达式内部. 在复合赋值语句
\begin{awkcode}
    FS = OFS = "\t"
\end{awkcode}
中, 字段分割符与输出字段分割符都被设置为制表符. 赋值表达式在条件判断中也
很常见, 例如:
\begin{awkcode}
    if ((n = length($0)) > 0) ...
\end{awkcode}

\emph{自增与自减} (\emph{Increment and Decrement Operators}). 赋值语句:
\begin{awkcode}
    n = n + 1
\end{awkcode}
通常写成 \verb'++n' 或 \verb'n++', 这里用到了一元自增运算符, 作用是给变量
加 1. 前缀形式 \verb'++n' 在传递 \verb'n' 的值之前为 \verb'n' 加 1; 后缀
形式 \verb'n++' 在传递 \verb'n' 的值之后, 为 \verb'n' 加 1. 当 \verb'++'
应用在赋值表达式中时, 这会造成一些不一样的地方. 如果 \verb'n' 的初始值为 1,
赋值语句 \verb'i = ++n' 为 \verb'n' 加 1, 并将新值 \verb'2' 赋给 \verb'i',
而 \verb'i = n++' 同样为 \verb'n' 加 1, 但将旧值 \verb'1' 赋给 \verb'i'.
如果仅仅是给 \verb'n' 加 1, 那么 \verb'n++' 与 \verb'++n' 没什么区别.
前缀与后缀自减运算符 \verb'--' 给变量减 1, 除此之外与 \verb'++' 相同.

\emph{内建算术函数} (\emph{Built-In Arithmetic Functions}). 内建算术函数在
表 \ref{tbl:built_in_arithmetic_functions} 中列出. 这些函数都可以作为主要
表达式使用. 在表格中, \textit{x} 与 \textit{y} 都是任意的表达式.

\begin{center}
\begin{figure}[ht]
    \begin{tabular}{l|l}
        \hline
        \hline
        函数    & 返回值    \\
        \verb'atan2('\textit{y}\textit{x}\verb')'   & $y/x$ 的反正切值,
        定义域在 $-\pi$ 到 $\pi$ 之间   \\
        \verb'cos('\textit{x}\verb')'   & \textit{x} 的余弦值, \textit{x}
        以弧度为单位    \\
        \verb'exp('\textit{x}\verb')'   & \textit{x} 的指数函数, $e^x$ \\
        \verb'int('\textit{x}\verb')'   & \textit{x} 的整数部分; 当
        \textit{x} 大于 0 时, 向 0 取整 \\
        \verb'log('\textit{x}\verb')'   & \textit{x} 的自然对数 (以 $e$ 为
        底  \\
        \verb'rand()'   & 返回一个随机数 \textit{r}, 0 <= \textit{r}
        < 1 \\
        \verb'sin('\textit{x}\verb')'   & \textit{x} 的正弦值, \textit{x}
        以弧度为单位.   \\
        \verb'sqrt('\textit{x}\verb')'  & \textit{x} 的方根 \\
        \verb'srand('\textit{x}\verb')' & \textit{x} 是 \verb'rand()' 新的
        随机数种子  \\
        \hline
    \end{tabular}
\end{figure}
\end{center}

可以用这些函数来得到一些有用的常量: \verb'atan2(0,-1)' 得到 \pi,
\verb'exp(1)' 返回 $e$ --- 自然对数的底. 为了计算 \textit{x} 的以 10 为底
的对数, 我们可以用 \verb'log('\textit{x}\verb')/log(10)' 来实现.

\verb'rand()' 返回一个大于等于 0, 小于 1 的伪随机浮点数. 调用
\marginpar{40}
\verb'srand('\textit{x}\verb')' 可以使随机数生成器的开始点从 \textit{x} 开
始. 如果没有调用 \verb'srand', 每次程序运行时, \verb'rand'
都从同一个值开始.

赋值语句
\begin{awkcode}
    randint = int(n * rand()) + 1
\end{awkcode}
将 \verb'randint' 的值设置为 \verb'1' 到 \verb'n' 之间的一个整数, 包括
\verb'1' 与 \verb'n'. 这里我们用到函数 \verb'int' 来丢弃返回值的小数部分.
赋值语句
\begin{awkcode}
    x = int(x + 0.5)
\end{awkcode}
将正数 \verb'x' 四舍五入为最接近它的整数.

\emph{字符串运算符} (\emph{String Operators}). Awk 中只有一种字符运算符 ---
连接. 连接并没有显式的运算符, 字符串可以通过这些方式创建: 字符串常量, 变量,
数组元素, 函数返回值, 以及其他与之相信的表达式, 程序
\begin{awkcode}
    { print NR ":" $0
\end{awkcode}
会将每一个输出行打印出来, 并在前面冠上行号, 以及一个冒号, 行号, 冒号与输入
行之间没有空格. 数值 \nr 会被自动转换成字符串 (如果必要的话, \verb'$0' 也
会做相同的转换); 然后三个字符串连接在一起并打印出来.

\emph{作为正则表达式的字符串} (\emph{Strings as Regular Expressions}).
到目前为止, 在所有的匹配表达式中, \verb'~' 与 \verb'!~' 右边的操作数都是
都是一个被斜杆包围起来的正则表达式. 但实际上, 任意一个表达式都可以用作匹配
运算符的右操作数. Awk 对这些表达式求值, 如果必要的话将这些值转换成字符串,
再将这些字符串解释成字符串. 例如, 程序
\begin{awkcode}
    BEGIN { digits = "^[0-9]+$" }
    $2 ~ digits
\end{awkcode}
会将那些第 2 个字段有且仅有数字的行打印出来.

因为字符串可以被拼接起来, 于是一个正则表达式可以由多个子部分共同构成.
下面这个程序将那些具有有效的浮点数的行打印出来:
\begin{awkcode}
    BEGIN {
        sign = "[+-]?"
        decimal = "[0-9]+[.]?[0-9]*"
        fraction = "[.][0-9]+"
        exponent = "([eE]" sign "[0-9]+)?"
        number = "^" sign "(" decimal "|" fraction ")" exponent "$"
    }
    $0 ~ number
\end{awkcode}
在一个匹配表达中, 一个被双引号包围的字符串, 可以与一个被斜杆包围的正则
\marginpar{41}
达式互换着使用, 例如 \verb'"^[0-9]+$"' 与 \verb'/^[0-9]+$'. 然而有一个
例外, 如果被双引号包围的字符串想要匹配一个正则表达式元字符的字面值, 当写
成被斜杆包围的形式时, 就要在反斜杆的前面再加一个反斜杆, 来保护它. 于是
\begin{awkcode}
    $0 ~ /(\+|-)[0-9]+/
\end{awkcode}
与
\begin{awkcode}
    $0 ~ "(\\+|-)[0-9]+"
\end{awkcode}
是等价的.

这种性质可能看起来非常晦涩难懂, 但是, 被双引号包围的字符串被 awk 解析时,
起保护作用的反斜线就会被移除, 这样想的话应该就容易理解多了. 如果一个正则
表达式的元字符需要一个反斜杆来暂时移除它的特殊意义, 那么在字符串中,
这个反斜杆就需要一个额外的一个反斜杆来保住它自己. 如果一个匹配运算符的右
操作数是一个变量或字段, 正如
\begin{awkcode}
    x ~ $1
\end{awkcode}
那么第 1 个字段中的反斜杆就不需要一层额外的保护, 因为在数据中反斜杆并没有
特殊的意义.

顺便说一句, 测试一下你对正则表达式交互性的理解是很容易的: 程序
\begin{awkcode}
    $1 ~ $2
\end{awkcode}
可以让你输入一个字符串与一个正则表达式; 如果字符串匹配正则表达式的话, 它
就会回射该行.

\emph{内建字符串函数} (\emph{Built-In String Functions}). 表
ref{tbl:built_in_string_functions} 列出了 awk 的内建字符串函数. 在这张表
中, \textit{r} 表示一个正则表达式 (或者是一个字符串, 或者是被一对斜杆包围
了的). \textit{s} 与 \textit{t} 是字符串表达式, \textit{n} 与 \textit{p}
是整数.
\begin{figure}[ht]
    \caption{内建字符串函数}
    \label{tbl:built_in_string_functions}
    \begin{center}
        \begin{tabular}{l|l}
            \hline
            \hline
            函数    & 描述  \\
            \hline
            \verb'gsub('\textit{r}\verb','\textit{s}\verb')' &  将
            \verb'$0' 中所有出现的 \textit{r} 替换为 \textit{s}, 返回
            替换发生的次数. \\
            \verb'gsub('\textit{r}\verb','\textit{s}\verb','\textit{t}
            \verb')'    & 将字符串 \textit{t} 中所有出现的 \textit{r}
            替换为 \textit{s}, 返回替换发生的次数 \\
            \verb'index('\textit{s}\verb','\textit{t}\verb')' & 返回字符串
            \textit{t} 在 \textit{s}中第一次出现的位置, 如果\textit{t}
            没有出现的话, 返回 0.   \\
            \verb'length('\textit{s}\verb')'    & 返回 \textit{s} 包含的
            字符个数 \\
            \verb'match('\textit{s}\verb','\textit{r}\verb')'   &
            测试 \textit{s} 是否包含能被 \textit{r} 匹配的子串, 返回索引或
            0; 设置 \verb'RSTART' 与 \verb'RLENGTH' \\
            \verb'split('\textit{s}\verb','\textit{a}\verb')'   &
            用 \verb'FS' 将 \textit{s} 分割到数组 \textit{a} 中, 返回字段
            的个数  \\
            \verb'split('\textit{s}\verb','\textit{a}\verb','\textit{fs}%
            \verb')'    & 用 \textit{fs} 分割 \textit{s} 到数组 \textit{a}
            中, 返回字段的个数  \\
            \verb'sprintf('\textit{fmt}\verb','\textit{expr-list}\verb')'
            & 根据格式字符串 \textit{fmt} 返回格式化后 \textit{expr-list}
            \\
            \verb'sub('\textit{r}\verb','\textit{s}\verb')' &
            将 \verb'$0' 的最左最长的, 能被 \textit{r} 匹配的子字符串替换为
            \textit{s}, 返回替换发生的次数. \\
            \verb'sub('\textit{r}\verb','\textit{s}\verb','\textit{t}%
            \verb')'    & 把 \textit{t} 的最左最长的, 能被 \textit{r} 匹配
            的子字符串替换为 \textit{s}, 返回替换发生的次数.    \\
            \verb'substr('\textit{s}\verb','\textit{p}\verb')'  &
            返回 \textit{s} 中从位置 \textit{p} 开始的后缀.\\
            \verb'substr('\textit{s}\verb','\textit{p}\verb','\textit{n}%
            \verb')'    & 返回 \textit{s} 中从位置 \textit{p} 开始的, 长
            度为 \textit{n} 的子字符串. \\
            \hline
        \end{tabular}
    \end{center}
\end{figure}

函数 \verb'index('\textit{s}\verb','\textit{t}\verb')' 返回 \textit{t} 在
\textit{s} 中第一次出现的位置; 如果 \textit{t} 没有在 \textit{s} 中出现,
那就返回 0. 字符串的第一个字符的位置是 1:
\begin{awkcode}
    index("banana", "an")
\end{awkcode}
返回 2.

函数 \verb'match('\textit{s}\verb','\textit{r}\verb')' 返回 \textit{s} 中
最左最长的, 能被 \textit{r} 匹配的子串, 返回值是子串在 \textit{s} 中的开始
位置, 如果没有找到相匹配的子串, 那就返回 0. 这个函数还会将内建变量
\verb'RSTART' 置为子串的起始位置, 将 \verb'RLENGTH' 置为子串的长度.

函数 \verb'split('\textit{s}\verb','\textit{a}\verb','\textit{fs}\verb')'
根据分割符 \textit{fs} 将字符串 \textit{s} 分割成一个个子串, 并存到数组
\textit{a} 中. 这个函数会在数组之后讨论, 也就是在这一节的末尾.

\marginpar{42}
\verb'sprintf('\fmt\verb','\expr$_1$\verb','\expr$_2$\verb','\ldots%
\verb','\expr$_n$\verb') 返回 (不打印) 一个字符串, 这个字符串包含格式化了的
\expr$_1$, \expr$_2$, \ldots, \expr$_n$, 格式化的依据与 \printf 的格式说
明符相同, \printf 的格式说明符就是 \fmt. 于是, 语句
\begin{awkcode}
    x = sprintf("%10s %6d", $1, $2)
\end{awkcode}
把一个字符串赋值给 \verb'x', 这个字符串通过%
把 \verb'$1' 格式化成 10 个字符宽度的字符串, 把 \verb'$2' 格式化成至少 6
个字符宽度的十进制整数来生成. \ref{sec:output} 节包含了一个完整的, 关于
格式转换字符的描述.

自从 Unix 文件编辑器 \verb'ed' 的替换命令出现之后, \verb'sub' 与
\verb'gsub' 就已经被模式化了.
\verb'sub('\textit{r}\verb','\textit{s}\verb','\textit{t}\verb')' 首先在
目标字符串 \textit{t} 找到能被 \textit{r} 匹配的最左最长子串, 再将这个子串
替换为 \textit{s}. 在 \verb'ed' 中, ``最左最长'' 意味着先找到最左边的匹配,
然后尽可能的延长匹配的长度.

如果目标字符串是 \verb'banana', 那么 \verb'anan' 就是正则表达式
\verb'(an)+' 的最左最长匹配. 相反, \verb'(an)*' 的最左最长匹配是 \verb'b'
左边的空字符串.

\verb'sub' 返回替换发生的次数.
\verb'sub('\textit{r}\verb','\textit{s}\verb')' 等价于
\verb'gsub('\textit{r}\verb','\textit{s}\verb','\verb'$0'\verb')'.

\verb'gsub' 是类似的, 但是它会连续地替换最左最长且不重叠的子串, 而不是只
替换子串的第一次出现; 函数返回值仍然是替换发生的次数\footnote{由此可见
\verb'sub' 的返回值小于等于 1, 而 \verb'gsub' 返回值大于等于 0. ---- 译者}.
\marginpar{43}
(\verb'gsub' 的 \verb'g' 是 ``global'' 的缩写, 意思是替换是全局). 例如,
程序
\begin{awkcode}
    { gsub(/USA/, "United States"); print }
\end{awkcode}
将输入行中的每一个 ``USA'' 替换为 ``United States'' (在这样的例子里,
当 \verb'$0' 发生改变时, 字段与 \nf 也会跟着发生改变). 程序
\begin{awkcode}
    gsub(/ana/, "anda", "banana")
\end{awkcode}
将 \verb'banana' 变为 \verb'bandana'; 匹配是不重叠的.

对一个由 \verb'sub' 或 \verb'gsub' 执行的替换来说, 字符 \verb'&' 在
\textit{s} 中任意一次出现都会被替换为被 \textit{r} 匹配的子串. 于是
\footnote{在 mawk-1.3.3 中, \verb'sub' 与 \verb'gsub'
的第 3 个参数 \textit{t} 必须是变量. ---- 译者}
\begin{awkcode}
    gsub(/a/, "aba", "banana")
\end{awkcode}
将 \verb'banana' 变为 \verb'babanabanaba'; 同样的效果也可用
\begin{awkcode}
    gsub(/a/, "&b&", "banana")
\end{awkcode}
来实现. 在 \verb'&' 的左边加上一个反斜杆就可以关闭它在替换字符串中的特殊
意义.

\verb'substr('\textit{s}\verb','\textit{p}\verb')'
返回 \textit{s} 从位置 \textit{p} 开始的后缀. 如果使用了
\verb'substr('\textit{s}\verb','\textit{p}\verb')', 那么只会返回后缀的
前 \textit{n} 字符; 如果后缀的长度小于 \textit{n}, 那么就会返回整个后缀.
例如, 我们可以将国家名缩写为名字的前三个字母, 程序
\begin{awkcode}
    { $1 = substr($1, 1, 3); print $0 }
\end{awkcode}
输出
\begin{awkcode}
    USS 8649 275 Asia
    Can 3852 25 North America
    Chi 3705 1032 Asia
    USA 3615 237 North America
    Bra 3286 134 South America
    Ind 1267 746 Asia
    Mex 762 78 North America
    Fra 211 55 Europe
    Jap 144 120 Asia
    Ger 96 61 Europe
    Eng 94 56 Europe
\end{awkcode}
修改 \verb'$1' 使得 awk 重新计算 \verb'$0', 于是字段之间的分隔符就变成了
空格 (\verb'OFS' 的默认值), 而不是制表符.

只要将字符串陆续写出来就可以将它们拼接在一起. 例如, 对于
\filename{countries}, 程序
\begin{awkcode}
        { s = s substr($1, 1, 3) " " }
    END { print s}
\end{awkcode}
打印
\marginpar{44}
\begin{awkcode}
    USS Can Chi USA Bra Ind Mex Fra Jap Ger Eng
\end{awkcode}
程序每一次只为 \verb's' 构造一小段. (如果你很在意 \verb's' 的末尾的空格,
在 \verb'END' 使用
\begin{awkcode}
    print substr(s, 1, length(s)-1)
\end{awkcode}
替换 \verb'print s')

\emph{数值还是字符串?} (\emph{Number or String?}). 表达式的值可以自动从
数值转换为字符串, 或反之, 具体取决于该值将用于什么运算. 算术表达式, 例如
\begin{awkcode}
    pop + $3
\end{awkcode}
这个表达式要求 \verb'pop' 与 \verb'$3' 都必须是数值, 如果它们原来不是数值
的话, 就会被强制转换成数值. 类似的, 赋值语句
\begin{awkcode}
    pop += $3
\end{awkcode}
也要求 \verb'pop' 与 \verb'$3' 是数值. 字符串表达式, 就像
\begin{awkcode}
    $1 $2
\end{awkcode}
要求 \verb'$1' 与 \verb'$2' 必须是字符串才能进行拼接, 所以如果必要的话,
它们就会被强制转换成字符串.

同样的运算符有时既可以用在数值上, 也可以用在字符串, 对于这种情况有一些特殊
的规则. 在赋值语句 \textit{v}\ \verb'='\ \textit{e} 中, 赋值语句本身与变量
\textit{v} 都会对表达式 \textit{e} 的有所要求. 比较表达式, 就像
\begin{awkcode}
    x == y
\end{awkcode}
如果两个操作数都是数值, 那么比较就按照数值进行; 否则, 数值类型的操作数被
强制转换成字符串, 然后再字符串的方式进行比较.

现在让我们来查看一下这条规则具体应用时会产生什么影响, 语句
\begin{awkcode}
    $1 ==  $2
\end{awkcode}
涉及到字段. 在这个语句里, 比较的类型取决于两个字段是否包含数值或字符串,
而这只有到程序运行时才可以知道; 对于不同的行, 比较的类型可能是不一样的.
当 awk 在运行状态下创建一个字段时, 会自动将它的类型设置为字符串; 另外,
如果字段包含一个机器可表示的数, 它也会给这个字段设置一个数值类型.

例如, 比较 \verb'$1 == $2' 将会按照数值进行, 并且比较结果为真, 如果
\verb'$1' 与 \verb'$2' 的值是下面任意一种的话,
\begin{file}
    1   1.0    +1   1e0    0.1e+1   10E-1    001
\end{file}
\marginpar{45}
这些值都是数值 1 的不同表示方法. 然而, 这个表达式也可以是字符串比较, 于是,
该表达式对下面每对值都会比较失败:
\begin{file}
    0           (null)
    0.0         (null)
    0           0a
    1e500       1.0e500
\end{file}
在前三对值中, 第二个字段都不是一个有效的数值.
最后一对值也会按照字符串来比较,
这是因为如果将它们转换成数值的话, 其值大得无法在机器上表示.

输出语句
\begin{awkcode}
    print $1
\end{awkcode}
打印第 1 个字段的字符串值; 于是, 输出与输入是一样的.

未初始化的变量默认初始值为数值 0 或空字符串 \verb'""'.
不存在或显式为空的字段具有字符串值 \verb'""', 它们不是数值, 但是当强制
转换为数值时, 将会是 0. 我们将在本节的末尾看到, 数组的下标是字符串.

有两种惯用语法可以将表达式从一种类型转换成另一种类型:
\begin{pattern}
    \textit{number} \verb'""'   将空字符串拼接到 \textit{number} 可以将它
    强制转换成字符串;
    \textit{string} \verb'+ 0'  给字符串加上零可以把它强制转换成数值.
\end{pattern}
于是, 为了强制让两个字段之间的比较按照字符串来进行, 我们可以把其中一个字段
强制转换成字符串:
\begin{awkcode}
    $1 + 0 == $2
\end{awkcode}
为了让比较强制按照数值类型来进行, 我们需要将\emph{两个}字段都转换成数值:
\begin{awkcode}
    $1 + 0 == $2 + 0
\end{awkcode}
无论字段包含什么内容, 这个方式总能奏效.

字符串的数值类型的值, 等于字符串最长的看起来像数值的前缀的值. 于是
\begin{awkcode}
    BEGIN { print "1E2"+0, "12E"+0, "E12"+0, "1X2Y3"+0 }
\end{awkcode}
输出
\begin{file}
    100 12 0 1
\end{file}

数值的字符串形式需要根据 \verb'OFMT' 转换后才会输出. 为了拼接, 比较, 与
数组下标的创建而需要将数值转换成字符串时, \verb'OFMT' 也会影响转换的过程.
\verb'OFMT' 的默认值是 \verb'"%.6g". 于是
\begin{awkcode}
    BEGIN { print 1E2 "", 12E-2 "", E12 "", 1.23456789 "" }
\end{awkcode}
输出
\begin{file}
    100 0.12  1.23457
\end{file}
\marginpar{46}
向 \verb'OFMT' 赋予新值就可以修改它的默认值. 比如将 \verb'OFMT' 改为
\verb'"%.2f"', 那么在打印数值, 以及强制转换而成的数值之间进行比较时, 小数
点后将会保留两位小数.
\begin{figure}[ht]
    \caption{表达式运算符}
    \label{tbl:expression_operators}
    \begin{center}
        \hline
        \hline
        操作    & 运算符    & 例子  & 例子的含义    \\
        \hline
        赋值    & \verb'= += -= *=' \verb'/= %= ^=' & \verb'x *= 2' &
        \verb'x = x * 2'
        条件表达式 & \verb'?:' & \verb'x ? y : z' & 若 \verb'x' 为真, 则
        \verb'y', 否则 \verb'z' \\
        逻辑 或 & \verb'||' & \verb'x || y' & 若 \verb'x' 或 \verb'y' 为
        真, 则为 1, 否则为 0
        逻辑 与 & \verb'&&' & \verb'x && y' & 若 \verb'x' 与 \verb'y' 都为
        真, 则为 1, 否则为 0 \\
        数组成员匹配 & \verb'in' & \verb' i in a' & 如果 \verb'a[i]' 存在,
        则为 1, 否则为 0 \\
        关系运算 & \verb'< <= == !=' \verb'>= >' & \verb'x == y' &
        如果 \verb'x' 等于 \verb'y', 则为 1, 否则为 0 \\
        拼接 & & \verb'"a" "bc"' & \verb'"abc"'; 不存在显式的拼接运算符 \\
        减法, 加法 & \verb'+ -' & \verb'x + y' & \verb'x' 与 \verb'y'
        的和 \\
        乘法, 除法, 取模 & \verb'* / %' & \verb'x % y' & \verb'x' 除以
        \verb'y' 的余数 \\
        单目加, 单目减 & \verb'+ -' & \verb'-x' & \verb'x' 的相反数 \\
        逻辑 非 & \verb'!' & \verb'!$1' & 若 \verb'$1' 为空或为 0, 则为 1,
        否则为 0 \\
        自增, 自减 & \verb'++ --' & \verb'++x, x++' & 为 \verb'x' 加 1 \\
        字段 & \verb'$' & \verb'$i+1' & 1 加上第 \verb'i' 个字段的值 \\
        组合 & \verb'( )' & \verb'($i)++' & 给第 \verb'i' 个字段的值加 1 \\
        \hline
    \end{center}
\end{figure}

\emph{运算符的总结} (\emph{Summary of Operators}). 可以出现在表达式中的运算
符全部列在了表 \ref{tbl:expression_operators} 中. 将这些运算符应用到常量,
变量, 字段, 数组元素, 函数, 和其他表达式中, 就可以构造一个表达式.

运算符按照优先级的升序排列. 优先级高的运算符优先求值; 举例来说, 在表达式
中, 乘法运算在加法运算之前求值. 所有的运算符都是左结合的, 除了赋值运算符,
条件运算符, 指数运算, 它们都是右结合的. 左结合性意味着相同优先级的运算符
按照从左到右的顺序进行运算; 于是 \verb'3-2-1' 是指 \verb'(3-2)-1', 而不是
\verb'3-(2-1)'.

因为没有显式的拼接运算符, 比较明智的做法是拼接运算中, 将涉及到其他运算的
\marginpar{47}
表达式用括号括起来. 考虑下面这个程序
\begin{awkcode}
    $1 < 0 { print "abs($1) = " -$1 }
\end{awkcode}
跟在 \print 后面的表达式看起来像是拼接, 实际上是一个减法运算. 程序
\begin{awkcode}
    $1 < 0 { print "abs($1) = " (-$1) }
\end{awkcode}
与
\begin{awkcode}
    $1 < 0 { print "abs($1) =", -$1 }
\end{awkcode}
都可以得到我们期望的效果.

\subsection{流程控制语句}
\label{subsec:control_flow_statements}

Awk 提供花括号用于语句组合, \verb'if-else' 用于决策, \verb'while',
\verb'for', \verb'do' 语句用于循环, 所有这些都来源于 C 语言.

一条单独的语句总是可以被替换为一个被花括号包围起来的语句列表. 列表中的语句
用换行符或封号分开. 换行符可以出现在任何左花括号之后, 也可以出现在任何右
花括号之后.

\verb'if-else' 具有形式:
\begin{pattern}
    \verb'if ('\expr\verb')'
    \stmt$_1$
    \verb'else'
    \stmt$_2$
\end{pattern}
\verb'else '\stmt$_2$ 是可选的. 右括号, \stmt$_1$, 和关键词 \verb'else' 后
面的换行符是可选的. 如果 \verb'else' 与 \stmt$_1$ 出现在同一行, 并且
\stmt$_1$ 是一条单独的语句, 那么在 \stmt$_1$ 的末尾必须使用封号来终止语句.

在一个 \verb'if-else' 语句中, 文本 \expr 先被求值. 如果 \expr 为真 (也就是
非空或非零), 那么 \stmt$_1$ 就会执行. 如果 \expr 为假 (也就是空或零),
如果 \verb'else '\stmt$_2$ 存在, 那它就会执行.

为了避免歧义, 我们规定, \verb'else' 与最近一个未匹配的 \verb'if' 匹配.
举例来说, 语句
\begin{awkcode}
    if (e1) if (e2) s=1; else s=2
\end{awkcode}
中的 \verb'else' 与第 2 个 \verb'if' 匹配. (\verb's=1' 后面的封号是必须的,
因为 \verb'else' 与 \verb's=1' 出现在同一行)

当条件为真时, \verb'while' 就会重复执行一条语句:
\begin{summary}{流程控制语句}
    \begin{enumerate}
        \item \verb'{'\stmt\verb'}' \\
            语句组合
        \item \verb'if ('\expr\verb')'\stmt \\
            如果 \expr 为真, 执行 \stmt
        \item \verb'if ('\expr\verb')' \stmt$_1$ \verb'else' \stmt$_2$ \\
            如果 \expr 为真, 执行 \stmt$_1$, 否则执行 \stmt$_2$
        \item \verb'while ('\expr\verb')' \stmt \\
            如果 \expr 为真, 执行 \stmt; 然后重复前面的过程
        \item \verb'for ('\expr$_1$\verb';'\expr$_2$\verb';'\expr$_3$
            \verb')' \stmt \\
            等价于 \expr$_1$\verb';' \verb'while ('\expr$_2$\verb') {'
            \stmt\verb';' \expr$_3$\verb'}'
        \item \verb'for ('\textit{variable} \verb'in'
            \textit{array}\verb')' \stmt \\
            轮流地将 \textit{variable} 设置为 \textit{array} 的每一个下标,
            并执行 \stmt
        \item \verb'do' \stmt \verb'while ('\expr\verb')' \\
            执行 \stmt; 如果 \expr 为真就重复
        \item \verb'break' \\
            马上离开最内层的, 包围 \verb'break' 的 \verb'while',
            \verb'for' 或 \verb'do'
        \item \verb'continue'
            开始最内层的, 包围 \verb'continue' 的 \verb'while', \verb'for',
            或 \verb'do' 下一次循环
        \item \verb'next'
            开始主输入循环的下一次迭代
        \item \verb'exit'
        \item \verb'exit' \expr \\
            马上进行 \END 动作; 如果已经在 \END 动作内, 那就寻出程序.
            将 \expr 作为程序的退出状态返回.
    \end{enumerate}
\end{summary}
\marginpar{48}
\begin{pattern}
    \verb'while ('\expr\verb')'
    \stmt
\end{pattern}
右括号后面的换行符是可选的. 在这个循环语句里, \expr 被求值; 如果它的值为
真, \stmt 就会执行, 然后 \expr 再被求值. 只要 \expr 为真, 循环就会一直
持续下去. 举例来说, 下面这个程序打印所有的输入字段, 每行一个:
\begin{awkcode}
    {   i = 1
        while (i <= NF) {
            print $1
            i++
        }
    }
\end{awkcode}
当 \verb'i' 到达 \verb'NF+1' 时, 循环停止, 这也是循环结束时 \verb'i' 的值.

\verb'for' 语句是 \verb'while' 的更加一般的形式:
\begin{pattern}
    \verb'for ('\expr$_1$\verb';'\expr$_2$\verb';'\expr$_3$\verb')'
    \stmt
\end{pattern}
\margin{49}
