% vim: ts=4 sts=4 sw=4 et tw=75

\chapter{Awk 语言}
\label{chap:the_awk_language}

\marginpar{21}
这一章解释---大部分都带有例子---构成一个 awk 程序的构造要素. 由于这次要描述
的是整个语言, 所以材料会非常琐细, 所以我们建议读者只需要浏览一下即可, 当
有必要的时候再回来查看细节.

最简单的 awk 程序是一个由多个 \patact 构成的序列:
\begin{pattern}
\textit{pattern} \texttt{\{} \textit{action} \texttt{\}} \par
\textit{pattern} \texttt{\{} \textit{action} \texttt{\}} \par
...
\end{pattern}
在某些语句中, 模式可以不存在; 还有些语句, 动作及其包围它的花括号也可以不存
在. 如果你的程序经过 awk 检查后没有发现语法错误, 它就会每次读取一个输入行,
对读取到的每一行, 按顺序检查每一个模式. 对每一个与当前行匹配的模式, 对应
的动作就会被执行. 一个缺失的模式匹配每一个输入行, 因此每一个不带有模式的动
作对每一个输入行都会执行. 只含有模式而没有动作的语句, 会打印每一个匹配模式
的输入行. 大部分情况下, 在这一章出现的术语 ``输入行'' 与 ``记录'' 被当作
一对同义词. 在 \ref{sec:input} 节, 我们都会讨论多行记录, 多行记录指的是一
个记录包含了多个行.

这一章的第一节会详细描述模式. 第二节通过描述表达式, 赋值语句与流程控制语句,
展开对动作的讨论. 剩下的小节包括函数定义, 输出, 输入, 以及 awk 如果调用其
他程序. 大部分小节都包含对主要性质的总结.

\subsection{输入文件\filename{countries}}
\label{subsec:the_input_file_countries}

作为本章许多 awk 程序的输入数据, 我们将使用文件 \filename{countries}. 每一
行都包括一个国家的名字, 面积 (以千平方英里为单位), 人口 (以百万为单位), 以
及这个国家所在的大陆. 数据来源于 1984 年, 苏联被归到了亚洲. 在文件里, 四列
数据用制表符分隔; 用一个空白符分隔 \texttt{North} (\texttt{South}) 与
\texttt{America}.

文件 \filename{countries} 包含下面几行:
\marginpar{22}
\begin{file}
    USSR        8649    275     Asia
    Canada      3852    25      North America
    China       3705    1032    Asia
    USA         3615    237     North America
    Brazil      3286    134     South America
    India       1267    746     Asia
    Mexico      762     78      North America
    France      211     55      Europe
    Japan       144     120     Asia
    Germany     96      61      Europe
    England     94      56      Europe
\end{file}

在这一章的剩下部分, 如果没有显式给出输入数据, 默认将 \filename{countries}
作为输入数据.

\subsection{程序格式}
\label{subsec:program_format}

\patact 语句, 以及动作内的语句通常用换行符分隔, 但是若干条语句也可出现在同
一行, 只要它们之间用分号分开即可. 一个分号可以放在任何语句的末尾.

动作的左花括号必须与它的模式在同一行; 而剩下的部分, 包括右花括号, 则可以出
现在下面几行.

空行会被忽略; 它们可以插入在语句之前或之后, 用来提高程序的可读性. 空格与制
表符可以出现在运算符与操作数的周围, 同样也是为了提高可读性.

注释可以出现在任意一行的末尾. 一个注释以井号 (\verb'#') 开始,
以换行符结束, 正如
\begin{awkcode}
    { print $1, $3 }    # print country name and population
\end{awkcode}

一条长语句可以分散成多行, 只要在断行处插入一个反斜杆即可:
\begin{awkcode}
    { print \
            $1,     # country name
            $2,     # area in thousands of square miles
            $3 }    # population in millions
\end{awkcode}
正如这个例子所呈现的那样, 语句可以在逗号之后断行, 并且注释可以插入在断行的
末尾.

在这本书里我们用到了若干种格式化风格, 之所以这样做, 一方面是为了比较不同的
风格之间的差异, 另一方面是为了避免程序占用过多的行. 对于比较短小的程序,
就像本章中出现过那些例子, 格式并不是非常重要, 但是一致性与可读性对于大程序
的管理非常有帮助.

\section{模式}
\label{sec:patterns}
\marginpar{23}

模式控制动作的执行. 这一小节描述模式的6种类型, 以及匹配它们的条件.
\begin{summary}{模式汇总}
    \begin{enumerate}
        \item \BEGIN \verb'{' \stmt \verb'}' \\
            在输入被读取之前, \stmt 被执行一次.
        \item \END \verb'{' \stmt \verb'}'      \\
            当所有输入被读取完毕之后, \stmt 被执行一次.
        \item \expr \verb'{' \stmt \verb'}' \\
            每碰到一个使 \expr 为真的输入行, \stmt 就被执行. \expr 为真指
            的是其值非零或非空.
        \item \verb'/'\regexpr\verb'/' \verb'{' \\
            \stmt \verb'}'
            当碰到这样一个输入行时, \stmt 就被执行: 输入行含有一段字符串,
            而该字符串可以被 \regexpr 匹配.
        \item \textit{compound pattern} \verb'{' \stmt \verb'}' \\
            一个复合模式将表达式用 \AND{}(AND), \OR{}(OR), \NOT{}(NOT), 以及
            括号组合起来; 当 \textit{compound pattern} 为真时, \stmt 执行.
        \item \pat$_1$\verb',' \pat$_2$ \verb'{' \stmt{}\verb'}' \\
            一个范围模式匹配多个输入行, 这些输入行从匹配 \pat$_1$ 的行开始,
            到匹配 \pat$_2$ 的行结束, 包括这两行; 对这其中的每一行执行
            \stmt.
    \end{enumerate}
    \BEGIN 与 \END 不与其他模式组合. 一个范围模式不能是其他模式的一部分.
    \BEGIN 与 \END 是唯一两个不能省略动作的模式.
\end{summary}

\subsection{\BEGIN 与 \END}
\label{subsec:begin_and_end}

\BEGIN 与 \END 这两个模式匹配任何输入行. 实际情况是, 当 awk 从输入读取数据
之前, \BEGIN 里的语句被执行; 当所有输入数据被读取完毕, \END 里的语句被执行.
于是, \BEGIN 与 \END 分别提供了一种控制初始化与扫尾的方式. \BEGIN 与 \END
不能与其他模式作组合. 如果有多个 \BEGIN, 与其关联的动作会按照它们在程序中
出现的顺序执行, 这种行为对多个 \END 同样适用. 我们通常将 \BEGIN 放在程序
开头, 将 \END 放在程序末尾, 虽然这并不是强制的.

\BEGIN 的一个常用用途是更改输入行被分割为字段的默认方式. 分割字符由一个内
建变量 \fs 控制. 默认情况下字段由空格或 (和) 制表符分割, 此时 \fs 的值被%
\marginpar{24}%
设置为一个空格符. 将 \fs 设置为一个不是空格的字符, 就会使该字符成为字段分
割符.

下面这个程序在 \BEGIN 的动作里将字段字割符设置为制表符 (\verb'\t'), 并在
输出之前打印标题. 第二个 \printf 语句 (对每一个输入行它都会被执行) 将输出
格式化成一个表格, 使得每一列都刚好与标题的列表头对齐. \END 打印总和. (变量
与表达式在 \ref{sec:actions} 节讨论.)
\begin{awkcode}
    # print countries with column headers and totals

    BEGIN { FS = "\t"   # make tab the field separator
            printf("%10s %6s %5s   %s\n\n",
                  "COUNTRY", "AREA", "POP", "CONTINENT")
          }
          { printf("%10s %6d %5d   %s\n", $1, $2, $3, $4)
            area = area + $2
            pop = pop + $3
          }
    END   { printf("\n%10s %6d %5d\n", "TOTAL", area, pop) }
\end{awkcode}
如果将 \filename{countries} 作为输入, 将出将是
\begin{file}
   COUNTRY   AREA   POP   CONTINENT

      USSR   8649   275   Asia
    Canada   3852    25   North America
     China   3705  1032   Asia
       USA   3615   237   North America
    Brazil   3286   134   South America
     India   1267   746   Asia
    Mexico    762    78   North America
    France    211    55   Europe
     Japan    144   120   Asia
   Germany     96    61   Europe
   England     94    56   Europe

     TOTAL  25681  2819
\end{file}

\subsection{用表达式作为模式}
\label{subsec:expressions_as_patterns}

就像大多数程序设计语言一样, awk 有着非常丰富的用来描述数值计算的表达式.
但是与许多语言不同的是, awk 还有用于描述字符串操作的表达式. 在整本书里,
\textit{string} 都表示一个由 0 个或多个字符组成的序列. 这些字符串可以存储
在变量中, 也可以以字符串常量的形式出现, 就像 \verb'""' 或 \verb'"Asia"'.
字%
符串 \verb'""' 不包括任何字符, 叫做 \cterm{空字符串} (\term{null string}).
术语 \cterm{子字符串} (\term{substring}) 表示一个字符串内部的, 由0个或多个
字符组成的连续序列. 对任意一个字符串, 空字符串都可以看作是该字符串第一个字
符之前的, 长度为0的子字符串, 或者是一对相邻字符之间的子字符串, 又或者是
最后一个字符之后的子字符串.

任意一个表达式都可以用作任意一个运算符的操作数.
如果一个表达式拥有一个数值形式%
\marginpar{25}%
的值, 而运算符要求一个字符串值, 那么该数值会自动转换成字符串, 类似地, 当
运算符要求一个数值时, 字符串被自动转换成数值.

任意一个表达式都可以当作模式来使用. 如果一个作为模式使用的表达式, 对当前
输入行的求值结果不空或非零, 那么该模式就匹配该行. 典型的表达式模式是那些
涉及到数值或字符串比较的表达式. 一个比较表达式包含 6 种关系运算符中的一种,
或者包含两种字符串匹配运算符中的一种: \verb'~' 与 \verb'!~' 在下一小节讨论.
这些运算列在表 \ref{tbl:comparison_operators} 中.
\begin{figure}[ht]
\captionsetup{type=table}
\caption{比较运算符}
\label{tbl:comparison_operators}
\begin{center}
\begin{tabular}{c|c}
    \hline
    \hline
    运算符      & 意义 \\
    \hline
    \verb'<'    & 小于 \\
    \verb'<='   & 小于或等于 \\
    \verb'=='   & 等于  \\
    \verb'!='   & 不等于 \\
    \verb'>='   & 大于或等于 \\
    \verb'>'    & 大于  \\
    \verb'~'    & 匹配 \\
    \verb'!~'   & 不匹配 \\
    \hline
\end{tabular}
\end{center}
\end{figure}

如果模式是一个比较表达式, 就像 \verb'NF > 10', 当当前行使该条件满足时, 这
个模式就算是匹配该输入行, 在这里条件满足指的是当前输入行的字段数大于 10.
如果模式是一个算术表达式, 就像 \nf, 如果该表达式的值非零, 那么当前输入行被
匹配. 如果模式是一个字符串表达式, 当表达式的字符串值非空时, 当前输入行被
匹配.

在一个关系比较中, 如果两个操作数都是数值, 关系比较将会按照数值比较进行;
否则的话, 数值操作数会被转换成字符串, 再将操作数按字符串的形式进行比较.
两个字符串间的比较按照字符逐个相比, 字符间的先后顺序依赖于机器提供的字符
集 (大多数情况下是 ASCII 字符集). 一个字符串 ``小于'' 另一个, 如果它比另
一个字符串更早出现的话, 例如 \verb'"Canada" < "China"',
\verb'"Asia" < "Asian"'.

模式
\begin{awkcode}
    $3/$2 >= 0.5
\end{awkcode}
选择那些第3个字段除以第2个字段的商大于0.5的输入行, 而
\begin{awkcode}
    $0 >= "M"
\end{awkcode}
\marginpar{26}
选择那些以字母 \verb'M', \verb'N', \verb'O' 等开头的输入行:
\begin{file}
    USSR	8649	275	Asia
    USA	3615	237	North America
    Mexico	762	78	North America
\end{file}

有时候一个比较运算符的类型不能单单靠表达式表现出来的语法形式来判断. 程序
\begin{awkcode}
    $1 < $4
\end{awkcode}
可以以数值的形式, 或者字符串的形式比较输入行的第1个与第4个字段. 在这里,
比较的类型取决于字段的值, 并且有可能每一行都有不同的情况出现. 文件
\filename{countries} 的第1与第4个字段总是字符串, 所以比较总是以字符串的形
式进行; 输出是
\begin{file}
    Canada	3852	25	North America
    Brazil	3286	134	South America
    Mexico	762	78	North America
    England	94	56	Europe
\end{file}
只有当两个字段都是数值时, 比较才会以数值的形式进行; 这种情况可以是
\begin{awkcode}
    $2 < $3
\end{awkcode}

\ref{sec:actions} 节包含了一个更加完整的, 关于字符串, 数值与表达式的讨论.

\subsection{字符串匹配 模式}
\label{subsec:string_matching_pattern}

Awk 提供了一种称为 \cterm{正则表达式} (\regexpr) 的表示法, 它可以用来指
定和
匹配一个字符串.  正则表达式 在 Unix 中使用得非常普遍, 包括文本编译器与
shell. 受限形式的正则表达式也出现在其他系统中, 在 MS-DOS 中可以用
``通配符'' 指定一个文件名集合.

一个 \cterm{字符串匹配模式} (\term{string-matching pattern})
测试一个字符串是否包含一段可以被正则表达式匹配的子字符串.

最简单的正则表达式是仅由数字与字母组成的字符串, 就像 \verb'Asia', 它匹配的
就是它自己. 为了将一个正则表达式切换成一个模式, 只需要用一对斜杆包围起来即
可:
\begin{awkcode}
    /Asia/
\end{awkcode}
这个模式匹配那些含有子字符串 \verb'Asia' 的输入行, 例如 \verb'Asia',
\verb'Asian', 或 \verb'Pan-Asiatic'. 注意, 正则表达式中空格是有意义的: 字
符串匹配模式
\marginpar{27}
\begin{summary}{字符串匹配模式}
    \begin{enumerate}
        \item \verb'/'\textit{regexpr}\verb'/' \\
            当当前输入行包含一段能够被 \textit{regexpr} 匹配的子字符串时,
            该模式被匹配.
        \item \regexpr {} \verb'~' \verb'/'\textit{regexpr}\verb'/' \\
            如果 \expr 的字符串值包含一段能够被 \textit{regexpr} 匹配的子
            字符时, 该模式被匹配.
        \item \expr {} \verb'!~' \verb'/'\textit{regexpr}\verb'/' \\
            如果 \expr 的字符串值不包含能够被 \textit{regexpr} 匹配的子字
            符串, 该模式被匹配.
    \end{enumerate}
    在 \verb'~' 与 \verb'!~' 的语境中, 任意一个表达式都可以出现在
    \verb'/'\textit{regexpr}\verb'/' 出现的地方.
\end{summary}

\begin{awkcode}
    / Asia /
\end{awkcode}
只有当 \verb'Asia' 被一对空格包围时才会被匹配.

上面的模式是三种字符串匹配模式当中的一种. 它的形式是用一对斜杆将正则表达式
包围起来:
\begin{pattern}
    \verb'/'\textit{r}\verb'/'
\end{pattern}
这个模式匹配那些含有能够被 \textit{r} 匹配的子字符串的输入行.

剩下的两种字符串匹配模式使用到了显式的匹配运算符:
\begin{pattern}
    \expr {} \verb'~' \verb'/'\textit{r}\verb'/' \par
    \expr {} \verb'!~' \verb'/'\textit{r}\verb'/'
\end{pattern}
匹配运算符 \verb'~' 的意思是 ``被...匹配'', \verb'!~' 的意思是 ``不被...%
匹配''. 当 \expr 的字符串值包含一段能够被正则表达式 \textit{r} 匹配的子字
串时, 第一个模式被匹配; 当不存在这样的子字符串时, 第二个模式被匹配.

匹配运算符的左操作数经常是一个字段: 模式
\begin{awkcode}
    $4 ~ /Asia/
\end{awkcode}
匹配所有{}第4个字段包含 \verb'Asia' 的输入行, 而
\begin{awkcode}
    $4 !~ /Asia/
\end{awkcode}
匹配所有{}第4个字段\cterm{不}包含 \verb'Asia' 的输入行.

注意到, 字符串匹配模式
\begin{awkcode}
    /Asia/
\end{awkcode}
是
\begin{awkcode}
    $0 ~ /Asia/
\end{awkcode}
的简写形式.

\subsection{正则表达式}
\label{subsec:regular_expressions}
\marginpar{28}
正则表达式是一种用于指定和匹配字符串的表示法. 就像算术表达式一样,
一个正则表达式是一个基本表达式, 或者是多个子表达式通过运算符组合而成.
为了理解被一个正则表达式匹配的字符串, 我们需要先了解被子表达式匹配的字符串.
\begin{summary}{正则表达式}
\begin{enumerate}
\item 正则表达式的元字符包括: \\
    \verb'\ ^ $ . [ ] | ( ) * + ?'
\item 一个基本的表达式包括下面几种: \\
    一个不是元字符的字符, 例如 \verb'A', 这个正则表达式匹配的就是它本身. \\
    一个匹配特殊符号的转义字符: \verb'\t' 匹配一个制表符 (见表
    \ref{tbl:escape_sequence}). \\
    一个被引述的元字符, 例如 \verb'\*', 按字面意义匹配元字符. \\
    \verb'^' 匹配一行的开始. \\
    \verb'$' 匹配一行的结束. \\
    \verb'.' 匹配任意一个字符. \\
    一个字符集合: \verb'[ABC]' 匹配字符 \verb'A', \verb'B' 或 \verb'C'. \\
    字符集合可能包含缩写形式: \verb'[A-Za-z]' 匹配单个字母. \\
    一个互补的字母集合: \verb'[^0-9]' 匹配任意一个字符, 但是除了数字.
\item 这些运算符将正则表达式组合起来:
    选择: \verb'A|B' 匹配 \verb'A' 或 \verb'B'. \\
    连接: \verb'AB' 匹配后面紧跟着 \verb'B' 的 \verb'A'. \\
    闭包: \verb'A*' 匹配0个或多个 \verb'A'. \\
    正闭包: \verb'A+' 匹配一个或多个 \verb'A'. \\
    零或一: \verb'A?' 匹配空字符串或 \verb'A'. \\
    括号: \verb'('\textit{r}\verb')' 匹配与 \textit{r} 相同的字符串.
\end{enumerate}
\end{summary}

基本的正则表达式在上面的表格中列出. 字符
\begin{file}
    \ ^ $ . [ ] | ( ) * + ?
\end{file}
叫作 \cterm{元字符} (\term{metacharacter}), 之所以这样称呼是因为它们具有
特殊的意义. 一个由单个非元字符构成的正则表达式匹配它自身. 于是, 一个字母
或一个数字都算作是一个基本的正则表达式, 与自身相匹配.  为了在正则表达式中
保留元字符的字面意义, 需要在字符的前面加上反斜杆. 于是, \verb'\$' 匹配
普通字符 \verb'$'. 如果某个字符前面冠有 \verb'\', 我们就说该字符是被
\cterm{引述} (\term{quoted}) 的.

在一个正则表达式中, 一个未被引述的脱字符 \verb'^' 表示一行的开始, 一个
未被引述的美元符 \verb'$' 匹配一行的结束, 一个未被引述的句点 \verb'.'
匹配任意一个字符. 于是,
\begin{tabbing}
    \verb'^C' \hspace{4em}  \= 匹配以字符 \verb'C' 开始的字符串; \\
    \verb'C$'   \> 匹配以字符 \verb'C' 结束的字符串; \\
    \verb'^C$'  \> 匹配只含有单个字符 \verb'C' 的字符串; \\
    \verb'^.$'  \> 匹配有且仅有一个字符的字符串; \\
    \verb'^...$' \> 匹配有且仅有3个字符的字符串; \\
    \verb'...'  \> 匹配任意3个字符; \\
    \verb'\.$'  \> 匹配以句点结束的字符串.
\end{tabbing}
\marginpar{29}

由一组被包围在方括号中的字符组成的正则表达式称为 \cterm{字符集合}
(\term{character class}); 这个表达式匹配字符集合中的任意一个字符. 例如,
\verb'[AEIOU]' 匹配 \verb'A', \verb'E', \verb'I', \verb'O' 或 \verb'U'.

使用连字符的字符集合可以表示一段字符范围. 紧跟在连字符左边的字符定义了范围
的开始, 紧跟在连字符右边的字符定义了范围的结束. 于是, \verb'[0-9]' 匹配
任意一个数字, \verb'[a-zA-Z][0-9]' 匹配一个后面紧跟着一个数字的字母. 如果
左右两边都没有操作数, 那么字符集合中的连字符就表示它本身, 所以 \verb'[+-]'
与 \verb'[-+]' 匹配一个 \verb'+' 或 \verb'-'. \verb'[A-Za-z-]' 匹配一个
含有连字符的单词.

一个 \cterm{互补} (\term{complemented}) 的字符集合在 \verb'[' 之后以
\verb'^' 开始. 这样一个集合匹配任意一个不在集合中的字符, ``集合中的字符''%
指的
是方括号内排在脱字符之后的那些字符. 于是, \verb'[^0-9]' 匹配任意一个不是
数字的字符; \verb'[^a-zA-Z]' 匹配任意一个不是字母的字符.
\begin{tabbing}
    \verb'^[ABC]' \hspace{4em}  \= 匹配以 \verb'A', \verb'B', 或 \verb'C'
        开始的字符串; \\
    \verb'^[^ABC]' \> 匹配以任意一个字符 (除了 \verb'A', \verb'B',
        或 \verb'C') 开始的字符串; \\
    \verb'[^ABC]' \> 匹配任意一个字符, 除了 \verb'A', \verb'B', 或
        \verb'C'; \\
    \verb'^[^a-z]$' \> 匹配任意一个有且仅有一个字符的字符串, 且该字
        符不能是小写字母.
\end{tabbing}

在一个字符集合内, 所有的字符都具有它自身的字面意义, 除了引述字符 \verb'\',
互补字符集合开头的 \verb'^', 以及两个字符间的 \verb'-'.
于是, \verb'[.]' 匹配一个句点, \verb'^[^^]' 匹配不以脱字符开始的字符串.

可以使用括号来指定正则表达式中的各个成分如何组合. 有两种二元正则表达式运算
符: 选择与连接. 选择运算符 \verb'|' 用来指定一个选择: 如果 \textit{r}$_1$
与 \textit{r}$_2$ 是正则表达式, 那么 \textit{r}$_1$\verb'|'\textit{r}$_2$
所匹配的字符串, 或者与 \textit{r}$_1$, 或者与 \textit{r}$_2$ 匹配.

Awk 不存在显式的连接运算符. 如果 \textit{r}$_1$ 与 \textit{r}$_2$ 是正则
表达式, 那么 \verb'('\textit{r}$_1$\verb')'\verb'('\textit{r}$_1$\verb')'
(在 \verb'('\textit{r}$_1$\verb')' 与 \verb'('\textit{r}$_2$\verb')' 之
间没有空格) 所匹配的字符串具有形式 \textit{xy}, 其中 \textit{x} 被
\textit{r}$_1$ 匹配, \textit{y} 被 \textit{r}$_2$ 匹配. \textit{r}$_1$ 或
\textit{r}$_2$ 两边的括号可以省略, 如果被括号包围的正则表达式不包含选择
运算符的话. 正则表达式
\begin{awkcode}
    (Asian|European|North American) (male|female) (black|blue)bird
\end{awkcode}
一共匹配12种字符串, 从
\begin{file}
    Asian male blackbird
\end{file}
到
\marginpar{30}
\begin{file}
    North American female bluebird
\end{file}

符号 \verb'*', \verb'+' 与 \verb'?' 是一元运算符, 用来指定正则表达式的
重复次数. 如果 \textit{r} 是一个正则表达式, 那么
\verb'('\textit{r}\verb')'\verb'*' 所匹配的字符串含有零个或连续的多个
能被 \textit{r} 匹配的子符串. \textit{r}\verb'?' 匹配的字符串, 要么是空字
符串, 要么是能够被 \textit{r} 匹配的字符串. 如果 \textit{r} 是一个基本的
正则表达式, 那么括号可以省略.
\begin{tabbing}
    \verb'B*' \hspace{4em} \= 匹配空字符串, 或 \verb'B', \verb'BB', 等等.\\
    \verb'AB*C' \> 匹配 \verb'AC', 或 \verb'ABC', \verb'ABBC', 等等. \\
    \verb'AB+C' \> 匹配 \verb'ABC', 或 \verb'ABBC', \verb'ABBBC', 等等.\\
    \verb'AB?C' \> 匹配 \verb'AC' 或 \verb'ABC' \\
    \verb'[A-Z]+' \> 匹配由一个或多个大写字母组成的字符串. \\
    \verb'(AB)+C' \> 匹配 \verb'ABC', \verb'ABABC', \verb'ABABABC', 等等.
\end{tabbing}

在正则表达式中, 选择运算符 \verb'|' 的优先级最低, 然后是连接运算, 最后是重
复运算符 \verb'*', \verb'+', 与 \verb'?'. 与算术表达式的规则一样, 优先
级高的运算符优先处理. 这种规则经常使得括号被省略: \verb'ab|cd' 等价于
\verb'(ab)|(cd)', \verb'^ab|cd*e$' 等价于 \verb'(^ab)|(c(d*)e$)'.

为了结束关于正则表达式的讨论, 这里列出了一些比较有用的字符串匹配模式的
例子, 这些例子都带有使用了一元与二元运算符的正则表达式, 同时还描述了能够
被该模式匹配的输入行. 回想一下, 如果当前输入行含有至少一个能够被
\textit{r} 匹配的子字符串, 那么模式 \verb'/'\textit{r}\verb'/'
匹配成功.
\begin{enumerate}
\item \verb'^[0-9]+$/' \\
    匹配含有且只含有数字的输入行.
\item \verb'^[0-9][0-9][0-9]$/' \\
    输入行有且仅有3个数字.
\item \verb'^(\+|-)?[0-9]+\.?[0-9]*$/' \\
    十进制小数, 符号与小数部分是可选的.
\item \verb'^[+-]?[0-9]+[.]?[0-9]*$/' \\
    也是匹配十进制小数, 带有可选的符号与小数部分.
\item \verb'^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$/' \\
    浮点数, 符号与指数部分是可选的.
\item \verb'^[A-Za-z][A-Za-z0-9]*$/' \\
    一个字母, 后面再跟着任意多个字母或数字 (比如 awk 的变量名).
\item \verb'^[A-Za-z]$|^[A-Za-z][0-9]$/' \\
    一个字母, 又或者是一个后面跟着一个数字的字母 (比如 Basic 的变量名).
\item \verb'^[A-Za-z][0-9]?$/' \\
    同样是一个字母, 又或者是一个后面跟着一个数字的字母.
\end{enumerate}
在第3个例子中, 为了匹配元字符\verb'+' 与 \verb'-' 的字面值, 必须在它们的
前面加上反斜线, 而在字符集合中则不需要, 所以第 3 项与 第 4 项的功能是等价
的.
\marginpar{31}

任意一个被一对斜线包围的正则表达式都可以作为匹配运算符的右操作数: 程序
\begin{awkcode}
    $2 !~ /^[0-9]+$/
\end{awkcode}
打印那些第2个字段不全是数字的行.

在正则表达式与字符串内部, awk 使用一个特定的字符序列--{}\cterm{转义序列}
(\term{escape sequences}){}--来表示那些无法用其他方式表示的字符. 例如,
\verb'\n'
表示一个换行符, 它无法以其他方式出现在字符串或正则表达式中; \verb'\b' 表示
退格符; \verb'\t' 表示制表符; \verb'007' 表示 ASCII 中的响铃符; \verb'\/'
表示一个斜杆. 转义序列在 awk 程序中才会有特殊的意义; 如果在数据中, 它们则
是普通的字符. 完整的转义序列名单在表 \ref{tbl:escape_sequences}.
\begin{figure}[ht]
\captionsetup{type=table}
\caption{转义序列}
\label{tbl:escape_sequences}
\begin{center}
\begin{tabular}{c|l}
    \hline
    \hline
    序列        &  \multicolumn{1}{c}{意义}  \\
    \hline
    \verb'\b'   & 退格  \\
    \verb'\f'   & 换页  \\
    \verb'\n'   & 换行 \\
    \verb'\r'   & 回车 \\
    \verb't'    & 制表符    \\
    \verb'\'\textit{ddd} & 八进制数 \textit{ddd}, \textit{ddd}
        含有 1 到 3 个数字, 每个数字的值在 0 到 7 之间 \\
    \verb'\'\textit{c} & 其他的字面意义上的 \textit{c}
        (举例来说, \verb'\\' 表示反斜杆, \verb'\"' 表示双引号) \\
    \hline
\end{tabular}
\end{center}
\end{figure}

表 \ref{tbl:regular_expressions} 总结了正则表达式, 以及它们所匹配的字符串.
运算符按优先级递增的顺序列出.
\begin{figure}[ht]
\captionsetup{type=table}
\caption{比较运算符}
\label{tbl:regular_expressions}
\begin{center}
\begin{tabular}{c|p{25em}}
    \hline
    \hline
    表达式  & \multicolumn{1}{c}{匹配}  \\
    \hline
    \textit{c}  & 非元字符 \textit{c}   \\
    \verb'\'\textit{c}   & 转义序列或字面意义上的 \textit{c} \\
    \verb'^'    & 字符串的开始 \\
    \verb'$'    & 字符串的结束  \\
    \verb'.'    & 任意一个字符 \\
    \verb'['\textit{c}$_1$\textit{c}$_2$...\verb']' & 任意一个在
        \textit{c}$_1$\textit{c}$_2$... 中的字符. \\
    \verb'[^'\textit{c}$_1$\textit{c}$_2$...\verb']'    & 任意一个不在
        \textit{c}$_1$\textit{c}$_2$... 中的字符. \\
    \verb'['\textit{c}$_1$\verb'-'\textit{c}$_2$...\verb']' & 任意一个在
        范围内的字符, 范围由 \textit{c}$_1$ 开始, 由 \textit{c}$_2$ 结束.
        \\
\verb'[^'\textit{c}$_1$\verb'-'\textit{c}$_2$...\verb']' & 任意一个不在
        范围内的字符, 范围由 \textit{c}$_1$ 开始,
        由 \textit{c}$_2$ 结束.  \\
    \textit{r}$_1$\verb'|'\textit{r}$_2$    & 任意一个被 \textit{r}$_1$
        或 \textit{r}$_2$ 匹配的字符串. \\
     \verb'('\textit{r}$_1$\verb')('\textit{r}$_2$\verb')'    &
         任意一个字串 \textit{xy}, 其中 \textit{r}$_1$ 匹配 \textit{x},
         而 \textit{r}$_2$ 匹配 \textit{y};
         如果当中不含有选择运算符, 那么
         括号是可以省略的 \\
     \verb'('\textit{r}\verb')*' & 零个或连续多个能被 \textit{r} 匹配
         的字符串. \\
     \verb'('\textit{r}\verb')+' & 一个或连续多个能被 \textit{r} 匹配
         的字符串. \\
     \verb'('\textit{r}\verb')?' & 零个或一个能被 \textit{r} 匹配
         的字符串. 在这里括号可以省略. \\
     \verb'('\textit{r}\verb')' & 任意一个能被 \textit{r} 匹配
         的字符串. \\
     \hline
\end{tabular}
\end{center}
\end{figure}

\subsection{复合模式}
\label{subsec:compound_patterns}

一个复合模式是一个组合了其他模式的表达式, 通过括号, 逻辑运算符 \OR{}(OR),
\AND{}(AND), \NOT{}(NOT) 来进行组合. 如果表达式的值为真, 那么复合模式就匹配
当前输入行. 下面这个程序使用 AND 运算符来选择那些第 4 个字段是 \verb'Asia'
且第 3 个字段大于 500 的行:
\marginpar{32}
\begin{awkcode}
    $4 == "Asia" && $3 > 500
\end{awkcode}
程序
\begin{awkcode}
    $4 == "Asia" || $4 == "Europe"
\end{awkcode}
使用 OR 运算符来选择那些第 4 个字段是 \verb'Asia' 或 \verb'Europe' 的行.
因为较后的这个查询是一个针对字符串的测试, 所以该程序的另一种写法是用到了
选择运算符的正则表达式:
\begin{awkcode}
    $4 ~ /^(Asia|Europe)$/
\end{awkcode}
