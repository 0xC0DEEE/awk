% vim: ts=8 sts=8 sw=4 et tw=75
\chapter{后记}
\label{chap:epilog}
\marginpar{181}

能看到这里, 说明读者在某种程度上已经是一个熟练的 awk 用户了, 至少不再是
一个笨拙的初学者. 当你在学习书中的示例程序时, 以及自己写程序的过程中, 
可能想知道 awk 为什么会是现在这个样子, 是否还有需要改进的地方.

本章的第一部分先讲一些历史故事, 然后讨论一下作为编程语言使用时, awk 有
哪些优点和缺点. 第二部分探讨 awk 程序的性能, 另外, 如果某个问题过于庞大,
以致于无法用一个单独的程序来解决时, 文章也提供了一些对问题进行重新规划
的方法.

\section{作为语言的 AWK}
\label{sec:awk_as_a_language}

关于 awk 的工作开始于 1977 年. 在那时候, 搜索文件的 Unix 程序
(\texttt{grep} 和 \texttt{sed}) 只支持正则表达式模式, 并且唯一能做的动作
只能替换和打印一整行数据, 还不存在字段和非数值操作. 我们当时的目标是
开发一款模式识别语言, 该语言支持字段, 包括用模式来匹配字段, 以及用动作
来操作字段. 最开始, 我们只能想它来转换数据, 验证程序的输入, 通过处理
输出数据来生成报表, 或对它们重新编排, 来作为其他程序的输入.

1977 年的 awk 只有很少的内建变量和预定义函数, 当时只是用它来写一些很简短
的程序, 就像第 \ref{chap:an_awk_tutorial} 章中出现的那些小程序. 后来,
我们写了一个小教程, 来指导新来的同事如何使用 awk. 正则表达式的表示法
来源于 \texttt{lex} 和 \texttt{egrep}, 其他的表达式和语句则来源于 C
语言.

Out model was that an invocation would be one or two lines long, typed in
and used immediately. 默认操作都是为了满足这个要求, 具体来说, 使用空格
作为默认的字段分隔符, 隐式地初始化, 变量的无类型声明, 等等, 这些都使得
单行程序变成可能. 作为作者, 我们非常清楚地知道 awk 将会被如何地使用,
所以我们只写单行程序.\footnote{原文是 We, being the authors, ``knew''
    how the language was supposed to be used, and so we only wrote
one-liners.}

\marginpar{182}
Awk 的快速传播强有力地推动了语言的发展. 把 awk 作为一门通用编程语言来使用,
而且能够这么快速地流行起来, 我们都感到非常的惊喜, 当看到一个无法在
一页内显示完毕的 awk 程序时, 我们的第一反应是震惊和惊异. 之所以会出现这种
情况是因为许多人在使用计算机时, 仅限于 shell (命令行语言) 和 awk, 而不
是使用一门 ``真正'' 的编程语言来开发程序 --- 他们经常过度伸展他们所喜爱
的工具.

为变量的值同时维护两种表示形式: 字符串与数值, 根据上下文来选择合适的形式
--- 这只是一个实验性设计, 目的是为了尽可能地使用同一套运算符集合来写出
简短的程序, 在字符串与数值的界限很模糊的情况下, 程序也要能正确地工作.
最终目标完成地很好, 但偶尔也会因为粗心而得到意料之外的运行结果. 第 
\ref{chap:the_awk_language} 章中介绍的规则可以用来解决界限模糊的情况, 它
们都来源于用户的使用经验.

关联数组的灵感来源于 SNOBOL4 表格 (虽然它们不具备 SNOBOL4 表格的通用性).
诞生 awk 的机器内存很小, 而且速度很慢, 正是这个环境造就了数组现在的性质.
把下标类型限制为字符串是其中一种表现, 另外的限制还包括单维数组 (虽然套了
一层语法外衣, 但本质上还是一维数组). 一个更加通用的实现应该支持多维数组,
至少支持数组元素可以是另外一个数组.

Awk 的主要设施在 1985 年被加入进来, 主要是为了满足用户需求. 添加的
功能包括动态正则表达式, 新的内建变量与内建函数, 多输入流, 以最重要的用
户自定义函数.

\texttt{match}, 动态正则表达式和新的字符串替换函数提供了非常有用的功能,
而且对用户来说, 只是稍微增加了一点复杂度.

在 \texttt{getline} 被引入之前, 输入数据的唯一种类是 \patact 语句所隐含
着的隐式输入循环. 这个限制条件确实太强了. 在原来的 awk 版本中, 对于具有
多个输入数据源的程序 (比如套用信函生成程序) 来说, 必须通过设置一个标志变量
(或其他类似的技巧) 来读取数据源. 而在新版的 awk 中, 多个输入数据可以在
\texttt{BEGIN} 部分, 用 \texttt{getline} 来读取. 另一方面, \texttt{getline}
是过载的, 它的语法和其他表达式相比并不一致. 其中一个问题是 \texttt{getline}
需要返回它所读取到的数据, 但同时也会返回表示成功或失败的返回值.

用户自定义函数的实现是一个折中方案, 从 awk 的最初设计开始, 出现了许多
困难. 我们并不打算在语言中加入声明, 这个设计造成的一个结果是声明局部
变量的特殊方法 --- 把局部变量写到参数列表中. 这种做法不仅看起来很陌生,
而且会让大型程序更容易出错. 另外, 缺少显式的字符串拼接运算符可以让程序
更加简短, 但这同时也要求在调用函数时, 必须在函数名之后紧跟上左括号. 不
管怎么说, 新的特性使得用 awk 编写大型程序变得更加容易.
\marginpar{183}
