\chapter{数据处理}
\label{chap:data_processing}

\marginpar{67}
Awk 最初的设计目标是用于日常的数据处理, 例如信息查询, 数据验证, 以及数据
转换与归约. 我们已经在第 \ref{chap:an_awk_tutorial} 章与第
\ref{chap:the_awk_language} 见到了关于这些的简单例子. 在这一章, 我们会按照
相同的思路, 考虑一些更加复杂的任务. 大多数例子一次只处理一行, 但是最后一节
讨论如何处理占据多行的输入记录.

Awk 程序通常按照增量模式开发: 先写上几行, 测试一下, 然后再添加几行, 再测试,
如此进行下去. 这本书里的大多数比较大的程序都是按照这种模式开发的.

也可以按照传统的方式来开发 awk 程序, 先拟好程序的主体框架, 然后查询手册.
但是, 通过修改已存在的程序来达到我们自己想要的效果, 通常来说会更加容易.
于是, 这本书里的程序扮演了另一个角色: 通过例子来提供实用的编程模型.

\section{数据转换与归约}
\label{sec:data_transformation_and_reduction}

Awk 的一个最常用的功能是把数据从一种形式转换成另一种形式, 通常情况下, 是把
一种程序的输出格式, 转换成另一种程序要求的格式. 另一个常用的功能是从一个大
数据集中提取相关的数据, 通常伴随着汇总信息的重新格式化与准备. 这一节包含了
许多关于这些主题的例子.

\subsection{列求和}
\label{subsec:Summing_columns}

我们已经看到了 2 行 awk 程序的几种变体, 这些程序对单个字段上的所有数字求和.
下面这个程序执行的工作更加复杂, 但却是比较典型的数据归约任务. 每一个输入行
都含有若干个字段, 每一个字段都包含数字, 程序的任务是计算每一列的和, 而不管
该行有多少列.
\begin{awkcode}
     # sum1 - print column sums
     #   input:  rows of numbers
     #   output: sum of each column
     #     missing entries are treated as zeros
     
         { for (i = 1; i <= NF; i++)
               sum[i] += $i
           if (NF > maxfld)
               maxfld = NF
         }
     END { for (i = 1; i <= maxfld; i++) {
               printf("%g", sum[i])
               if (i < maxfld)
                   printf("\t")
               else
                   printf("\n")
           }
         }
\end{awkcode}
\marginpar{68}
变量的自动初始化在这里显得非常方便, 因为 \verb'maxfld' (到目前为止, 看到的
字段数最大值) 自动从 0 开始, 随着程序的进行, 所有的项都被放入数组 \verb'sum'
中, 虽然只有到程序运行结束, 我们才能知道数组中到底有多少项. 值得注意的是,
如果输入文件为空, 那么程序什么也不会打印出来.

程序不需要知道一行有多少个字段, 这对我们写程序来说就非常方便, 但是它不检
查所有的项是否都是数字, 也不检查每行的字段数是否相同\footnote{原文为:
    but it doesn't check that the entries are all numbers, nor that each 
row has the same number of entries.}  下面的程序做的是同样的事件, 但是 
它会检查每行的字段数是否与每一行的相同:
\begin{awkcode}
     # sum2 - print column sums
     #     check that each line has the same number of fields
     #        as line one
     
     NR==1 { nfld = NF }
           { for (i = 1; i <= NF; i++)
                 sum[i] += $i
             if (NF != nfld)
                 print "line " NR " has " NF " entries, not " nfld
           }
     END   { for (i = 1; i <= nfld; i++)
                 printf("%g%s", sum[i], i < nfld ? "\t" : "\n")
           }
\end{awkcode}
我们还修正了位于 \END 的输出代码, 这段代码显示了如何利用条件表达式, 使得
在列与列之间插入一个制表符, 在最后一列之后插入一个换行符.

现在, 假设某些字段不是数值型, 所以它们不能被计算在内. 策略是新增一个数组
\verb'numcol', 用于跟踪数值型字段, 并且函数 \verb'isnum' 来检查某项是否是
一个数值. 由于使用到了函数, 所以测试只需要在一个地方完成, 这样做有助于将来
\marginpar{69}
对程序进行修改. 如果程序可以相信它的输入, 那么只需要查看第 1 行就可以知道
某个字段是否是数值. 我们仍然需要 \verb'nfld', 因为在 \END 中, \verb'NF' 的
值是零.
\begin{awkcode}
     # sum3 - print sums of numeric columns
     #     input:  rows of integers and strings
     #     output: sums of numeric columns
     #       assumes every line has same layout
     
     NR==1 { nfld = NF
             for (i = 1; i <= NF; i++)
                 numcol[i] = isnum($i)
           }
     
           { for (i = 1; i <= NF; i++)
                 if (numcol[i])
                     sum[i] += $i
           }
     
     END   { for (i = 1; i <= nfld; i++) {
                 if (numcol[i])
                     printf("%g", sum[i])
                 else
                     printf("--")
                 printf(i < nfld ? "\t" : "\n")
             }
           }
     
     function isnum(n) { return n ~ /^[+-]?[0-9]+$/ }
\end{awkcode}
函数 \verb'isnum' 把数值定义成一个或多个数字, 可能有前导符号. 关于数值更加
一般的定义可以在 \ref{sec:patterns} 节的正则表达式那样找到.

\exercise 修改程序 \verb'sum3', 使得它忽略空行.
\exercise 为数值添加更加一般的正则表达式. 它会如何影响运行时间?
\exercise 如果把第 2 个 \verb'for' 语句的 \verb'numcol' 测试拿掉, 会产生什
么影响?
\exercise 写一个程序, 这个程序读取一个\ 项目--数额\ 对列表, 对列表中的每一个
项目, 累加它的数额; 在结束时, 打印项目以及它的总数额, 项目按照字母顺序排序.

\subsection{计算百分比与分位数}
\label{subsec:computing_percentages_and_quantiles}

假设我们不想知道每列的总和, 但是想知道每一列所占的百分比. 要完成这个工作就
必须对数据遍历两遍. 如果只有一列是数值, 而且也没有太多的数据, 最简单的办法
是在第一次遍历时, 把数值存储在一个数组中, 每二次遍历时计算百分比并把它打印
出来:
\begin{awkcode}
     # percent
     #   input:  a column of nonnegative numbers
     #   output: each number and its percentage of the total
     
         { x[NR] = $1; sum += $1 }
     
     END { if (sum != 0)
               for (i = 1; i <= NR; i++)
                   printf("%10.2f %5.1f\n", x[i], 100*x[i]/sum)
         }
\end{awkcode}
\marginpar{70}

虽然复杂了一点, 但是它可以用于许多事情, 例如调整学生的成绩, 使得成绩分布符
合某种曲线. 一旦成绩计算完毕 (0 到 100 之间的数), 显示成一个直方图可能会比
较有趣:
\begin{awkcode}
    # histogram
    #   input:  numbers between 0 and 100
    #   output: histogram of deciles
    
        { x[int($1/10)]++ }
    
    END { for (i = 0; i < 10; i++)
              printf(" %2d - %2d: %3d %s\n",
                  10*i, 10*i+9, x[i], rep(x[i],"*"))
          printf("100:      %3d %s\n", x[10], rep(x[10],"*"))
        }
    
    function rep(n,s,   t) {  # return string of n s's
        while (n-- > 0)
            t = t s
        return t
    }
\end{awkcode}
需要注意的是后缀递增运算符 \verb'--' 如何控制 \verb'while' 循环.

我们可以用随机生成的成绩来测试 \verb'histogram'. 管道线上的第一个程序随机
生成 200 个 0 到 100 的整数, 并把这些整数输送给 \verb'histogram'
\begin{awkcode}
    awk '
    # generate random integers
    BEGIN { for (i = 1; i <= 200; i++)
                print int(101*rand())
          }
    ' |
    awk -f histogram
\end{awkcode}
它的输出是\footnote{这是在我系统上的运行结果, 因为成绩是随机生成的, 所以 
与原文不太一样}
\begin{shell}
      0 -  9:  20 ********************
     10 - 19:  18 ******************
     20 - 29:  20 ********************
     30 - 39:  16 ****************
     40 - 49:  23 ***********************
     50 - 59:  17 *****************
     60 - 69:  22 **********************
     70 - 79:  20 ********************
     80 - 89:  20 ********************
     90 - 99:  22 **********************
    100:        2 **
\end{shell}

\marginpar{71}
\begin{exercise}
    根据比较决定星号的个数, 使得当数据过多时, 一行的长度不会超过屏幕的宽度.
\end{exercise}

\begin{exercise}
    修改 \verb'histogram', 把输入分拣到指定数量的桶中, 根据目前为止看到的
    数据调整每个桶的范围.
\end{exercise}

\subsection{带逗号的数}
\label{subsec:numbers_with_commas}

设想我们有一张包含了许多数的表, 每个数都有逗号与小数点, 就像
\verb'12,345.67'. 因为 awk 认为第一个逗号会终止一个数, 所以这些数不能直接
相加. 必须首先把逗号移除:
\begin{awkcode}
    # sumcomma - add up numbers containing commas
    
        { gsub(/,/, ""); sum += $0 }
    END { print sum }
\end{awkcode}
\verb'gsub(/,/, "")' 作为是把每一个逗号都替换成空字符串, 也就是删除逗号.

这个程序不检查处于正确位置的逗号, 也不在答案中打印逗号. 往数字中加入逗号只
需要很少的工作量, 下一个程序就展示了这点. 它为数字加上逗号, 保留两位小数.
这个程序的结构是非常值得效仿的: 一个函数只负责添加逗号, 剩下的部分只管读取
与打印. 一旦测试通过, 新的函数就可以被包含到最终的程序中.

基本思路是在一个循环中, 从小数点开始, 从左至右, 在适当的位置插入逗号, 每
次迭代都把一个逗号放在最左边的三个数字的前面, 这三个数字后面跟着一个逗号或
小数点, 而且每一个逗号的前面至少有一个数字. 算法使用递归来处理负数: 如果 
输入参数是负数, 那么函数 \verb'addcomma' 使用正数来调用它自身, 返回时再加
上负号.
\begin{awkcode}
    # addcomma - put commas in numbers
    #   input:  a number per line
    #   output: the input number followed by
    #      the number with commas and two decimal places 
    
        { printf("%-12s %20s\n", $0, addcomma($0)) }
    
    function addcomma(x,   num) {
        if (x < 0)
            return "-" addcomma(-x)
        num = sprintf("%.2f", x)   # num is dddddd.dd
        while (num ~ /[0-9][0-9][0-9][0-9]/)
            sub(/[0-9][0-9][0-9][,.]/, ",&", num)
        return num
    }
\end{awkcode}
\marginpar{72}
请注意 \verb'&' 的用法, 通过文本替换, \verb'sub' 在每三个数字的前面插入一个
逗号.

这是某些测试数据的输出:
\begin{shell}
    0                            0.00
    -1                          -1.00
    -12.34                     -12.34
    12345                   12,345.00
    -1234567.89         -1,234,567.89
    -123.                     -123.00
    -123456               -123,456.00
\end{shell}

\begin{exercise}
    修复 \verb'sumcomma' (带逗号的数字求和程序), 使得它可以检查数字中的逗号
    是否处于正确位置?
\end{exercise}

\subsection{字段固定的输入}
\label{subsec:fixed_field_input}

对于那些出现在宽度固定字段里的信息, 在直接使用它们之前, 通常需要某种形式的
预处理. 有些程序 (例如电子表格) 在固定的列上面放置序号, 而不是给它们带上
字段分隔符\footnote{原文为 Some programs, such as spreadsheets, put out
numbers in fixed columns, rather than with field separators.} 如果序号太宽
了, 这些列就会邻接在一起. 字段固定的数据最适合用 \verb'substr' 处理,
它可以将任意组合的列挑选出来. 举例来说, 假设每行的前6个字符包含一个日期, 
日期的形式是 \verb'mmddyy', 如果我们想让它们按照日期排序, 最简单的办法是
先把日期转换成 \verb'yymmdd' 的形式:
\begin{awkcode}
    # date convert - convert mmddyy into yymmdd in $1
    
    { $1 = substr($1,5,2) substr($1,1,2) substr($1,3,2); print }
\end{awkcode}
如果输入是按照月份排序的, 就像这样
\begin{shell}
    013042 mary's birthday
    032772 mark's birthday
    052470 anniversary
    061209 mother's birthday
    110175 elizabeth's birthday
\end{shell}
那么程序的输出是
\begin{shell}
    420130 mary's birthday
    720327 mark's birthday
    700524 anniversary
    090612 mother's birthday
    751101 elizabeth's birthday
\end{shell}
\marginpar{73}
现在数据已经准备好, 可以按照年, 月, 日来排序了.

\begin{exercise}
    将日期转换成某种形式, 这种形式充许你对日期进行算术运算, 例如计算某两
    个日期之间的天数?
\end{exercise}

\subsection{程序的交叉引用检查}
\label{subsec:program_cross_reference_checking}

Awk 经常用于从其他程序的输出中提取信息, 有时候这些输出仅仅是一些同种类的行
的集合, 在这种情况下, 使用字段分割操作或函数 \verb'substr'
是非常方便且合适的. 然而, 有时候产生输出的程序本来就打算将输出表示成人类
可读的形式, 对于这种情况, awk 需要把精心格式化过的输出重新还原
成机器容易处理的形式, 只要这样, 才能从互不相关的数据中提取信息. 下面是一个
简单的例子.

大型程序通常由多个源文件组成. 知道哪些文件定义了哪些函数, 以及这些函数在哪
里被使用 ---- 可以带来许多方便之处 (有时候这是非常重要的). 为了完成这个
任务, Unix 提供了命令 \verb'nm', \verb'nm' 从一个目标文件集合中提取信息,
并打印一张精心格式化过的列表, 这张表包含了名字, 定义, 以及名字在哪里被使用
到. \verb'nm' 的典型输出是
\begin{shell}
    file.o:
    00000c80 T _addroot
    00000b30 T _checkdev
    00000a3c T _checkdupl
             U _chown
             U _client
             U _close
    funmount.o:
    00000000 T _funmount
             U cerror
\end{shell}
只有一个字段的行 (比如 \verb'file.o') 是文件名, 有两个字段的行 (比如 
\verb'U _close') 表示的是名字被使用到的地方, 有三个字段的行表示的是名字
被定义的地方. \verb'T' 表示这个定义是一个文本符号 (函数), \verb'U' 表示 
这个名字是未定义的.

如果直接利用这些未加处理过的信息, 来判断某个文件定义了哪些名字, 又或者是
某个符号都在哪里被用到 ---- 将会非常的麻烦, 因为每个符号都没有和它所在的
文件名放在一起. 对于稍微大型的 C 程序来说, \verb'nm' 的输出将会非常得长
---- awk 源代码由 9 个文件组成, 它的 \verb'nm' 输出超过了 850 行.
\marginpar{74}
一个仅仅 3 行的 awk 程序就可以把文件名加到每个符号的前面, 经过它的处理,
后续的程序仅通过一行就可以获取到有用的信息:
\begin{awkcode}
    # nm.format - add filename to each nm output line
    
    NF == 1 { file = $1 }
    NF == 2 { print file, $1, $2 }
    NF == 3 { print file, $2, $3 }
\end{awkcode}
把上面 \verb'nm' 的输出作为 \filename{nm.format} 的输入, 结果是
\begin{awkcode}
    file.o: T _addroot
    file.o: T _checkdev
    file.o: T _checkdupl
    file.o: U _chown
    file.o: U _client
    file.o: U _close
    funmount.o: T _funmount
    funmount.o: U cerror
\end{awkcode}
现在, 如果有其他程序想要对输出进行进一步的处理就容易多了.

上面的输出没有包括行号信息, 也没有指出某个名字在文件中被用到了多少次, 
但是这些信息很容易通过文本编辑器或另一个 awk 程序来获取. 本小节的 awk 程序 
不依赖于目标文件的编程语言, 所以它比通常的交叉引用工具更加灵活, 也更加
简短.

\subsection{格式化的输出}
\label{subsec:formatted_output}

接下来我们要用 awk 赚点钱, 或者是打印支票. 输入数据由多行组成, 每一行都包括
支票编号, 金额, 帐款人, 字段之间用制表符分开. 输出是标准的支票格式: 8行高,
第2行与第3行是支票编号与日期, 都向右缩进 45 个空格, 第4行是收款人, 占用
45 个字符宽的区域, 紧跟在它后面的是 3 个空格, 再后面是金额. 第 5 行是金额
的大写形式, 其他行都是空白. 支票看起来就像这样:
\begin{shell}

                                             1026
                                             Aug 31, 2015
Pay to Mary R. Worth--------------------------------   $123.45
the sum of one hundred twenty three dollars and 45 cents exactly



\edn{shell}
这是打印支票的 awk 程序:
\marginpar{75}
\begin{awkcode}
    # prchecks - print formatted checks
    #   input:  number \t amount \t payee
    #   output: eight lines of text for preprinted check forms
    
    BEGIN {
        FS = "\t"
        dashes = sp45 = sprintf("%45s", " ")
        gsub(/ /, "-", dashes)        # to protect the payee
        "date" | getline date         # get today's date
        split(date, d, " ")
        date = d[2] " " d[3] ", " d[6]
        initnum()    # set up tables for number conversion
    }
    NF != 3 || $2 >= 1000000 {        # illegal data
        printf("\nline %d illegal:\n%s\n\nVOID\nVOID\n\n\n", NR, $0)
        next                          # no check printed
    }
    {   printf("\n")                  # nothing on line 1
        printf("%s%s\n", sp45, $1)    # number, indented 45 spaces
        printf("%s%s\n", sp45, date)  # date, indented 45 spaces
        amt = sprintf("%.2f", $2)     # formatted amount
        printf("Pay to %45.45s   $%s\n", $3 dashes, amt)  # line 4
        printf("the sum of %s\n", numtowords(amt))        # line 5
        printf("\n\n\n")              # lines 6, 7 and 8
    }
    
    function numtowords(n,   cents, dols) { # n has 2 decimal places
        cents = substr(n, length(n)-1, 2)
        dols = substr(n, 1, length(n)-3)
        if (dols == 0)
            return "zero dollars and " cents " cents exactly"
        return intowords(dols) " dollars and " cents " cents exactly"
    }
    
    function intowords(n) {
        n = int(n)
        if (n >= 1000)
            return intowords(n/1000) " thousand " intowords(n%1000)
        if (n >= 100)
            return intowords(n/100) " hundred " intowords(n%100)
        if (n >= 20)
            return tens[int(n/10)] " " intowords(n%10)
        return nums[n]
    }
    
    function initnum() {
        split("one two three four five six seven eight nine " \
              "ten eleven twelve thirteen fourteen fifteen " \
              "sixteen seventeen eighteen nineteen", nums, " ")
        split("ten twenty thirty forty fifty sixty " \
              "seventy eighty ninety", tens, " ")
    }
\end{awkcode}

程序中包含了几个比较有趣的部分. 首先, 要注意到我们在 \BEGIN 中是如何利用
\marginpar{76}
\verb'sprintf' 来生成空格字符串的, 并且通过替换将空格字符串转换成连字符
字符串. 还要注意的是, 在函数 \verb'initnum' 中, 我们如何通过行的延续与
字符串拼接来创建 \verb'split' 的参数, 这是很常见的编程技巧.

日期通过
\begin{awkcode}
    "data" | getline data   # get today's date
\end{awkcode}
从系统获取, 该行执行 \verb'date', 再把它的输出输送给 \verb'getline'. 为了把
\begin{shell}
    Wed Jun 17 13:39:36 EDT 1987
\end{shell}
转换成 
\begin{shell}
    Jun 17, 1987
\end{shell}
我们需要自己做一些处理工作.
(在不支持管道的非Unix平台上, 该程序需要做些修改才能正确运行)

函数 \verb'numtowords' 与 \verb'intowords' 把数字转换成对应的单词, 转换过程
非常直接 (虽然程序用了一半的代码来做这件事). \verb'intowords' 是一个递归
函数, 它调用自身来处理一个规模较小的子问题, 这是本章的出现过的第 2 个递归
函数, 在后面我们还会遇到更多这样的函数. 在很多情况下, 为了把一个大问题分解
成相对容易解决的小问题, 递归都是一个非常有效的方法.

\begin{exercise}
    利用前面提到过的程序 \verb'addcomma', 为金额加上逗号.
\end{exercise}

\begin{exercise}
    对于负的, 或特别大的金额, 程序 \verb'prchecks' 处理得并不是很好. 修改 
    程序, 使得程序能够拒绝金额为负的打印请求, 同时能将数额特别巨大的金额
    分成两行打印出来.
\end{exercise}

\begin{exercise}
    函数 \verb'numtowords' 有时会在一行中打印两个空格, 还会打印出像 
    ``one dollars'' 这样有错误的句子, 你会如何消除这些瑕疵?
\end{exercise}

\begin{exercise}
    修复 \verb'prchecks', 使得它能够在适当的地方, 为金额的大写形式加上
    连字符, 比如 ``twenty-one dollars''.
\end{exercise}

\section{数据验证}
\label{sec:data_validation}

Awk 的另一个常用功能是数据验证: 确保数据是合法的, 或至少合理的. 本节包含了
几个用于验证输入有效性的小程序, 例如, 考虑上一节出现的列求和程序, 有没有
这样一种情况: 在本应是数值的字段上出现了非数值的量 (或反之) ? 下面这个程序 
与列求和程序非常相似, 但没有求和操作:
\marginpar{77}
\begin{awkcode}
    # colcheck - check consistency of columns
    #   input:  rows of numbers and strings
    #   output: lines whose format differs from first line
    
    NR == 1	{
        nfld = NF
        for (i = 1; i <= NF; i++)
           type[i] = isnum($i)
    }
    {   if (NF != nfld)
           printf("line %d has %d fields instead of %d\n",
              NR, NF, nfld)
        for (i = 1; i <= NF; i++)
           if (isnum($i) != type[i])
              printf("field %d in line %d differs from line 1\n",
                 i, NR)
    }
    
    function isnum(n) { return n ~ /^[+-]?[0-9]+$/ }
\end{awkcode}
同样, 我们把数值看成是仅由数字构成的序列, 可能有前导符号, 如果想让这个判断
更加完整, 请参考 \ref{sec:patterns} 节关于正则表达式的讨论.
