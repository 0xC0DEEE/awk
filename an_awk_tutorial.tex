% vim: ts=4 sts=4 sw=4 et tw=75

\chapter{快速入门}
\label{chap:an_awk_tutorial}

\marginpar{1}
Awk 是一种使用方便且表现力很强的编程语言, 它可以应用在许多种类的计算与数据
处理任务中. 这一章是一个简短的教程, 旨在让你尽可能快地写出自己的 awk 程序.
第 \ref{chap:the_awk_language} 章对整个 awk 语言进行描述, 剩下的章节展现了
在多种不同的领域中, 如何使用 awk 解决问题. 在这本书中出现的例子, 读者应该
会感到非常有用, 有趣且具有指导作用.

\section{开始}
\label{sec:getting_started}

有用的 awk 程序通常都很短, 只有一两行. 假设你有一个文件, 叫作
\filename{emp.data}, 这个文件包含有名字, 每小时工资 (以美元为单位),
工作时长, 每一行代表一个雇员的记录, 就像这样
\begin{file}
    Beth    4.00    0
    Dan     3.75    0
    Kathy   4.00    10
    Mark    5.00    20
    Mary    5.50    22
    Susie   4.25    18
\end{file}
现在你想要打印每位雇员的名字以及他们的报酬 (每小时工资乘以工作时长), 而雇员
的工作时长必须大于零. 这种类型的工作是 awk 的设计目标之一, 所以会很简单.
只要键入下面这一行即可:
\begin{awkcode}
    awk '$3 > 0 { print $1, $2 * $3 }' emp.data
\end{awkcode}
这一行命令告诉系统运行 awk 命令, 被运行的程序被单引号包围, 从输入文件
\marginpar{2}
\filename{emp.data} 获取数据. 被单引号包围的部分是一个完整的 awk 程序. 它由
一个单独的 \cterm{模式-动作 语句)} (\term{pattern-action statement}) 组成.
模式 \verb'$3 > 0' 匹配每一行输入, 如果该行的第三列, 或者说 \cterm{字段}
(\term{field}) 大于零, 则动作
\begin{awkcode}
    { print $1, $2 * $3 }
\end{awkcode}
就会为每一个匹配行打印第一个字段, 以及第二与第三个字段的乘积.

如果你想要打印没有工作的雇员的名字, 键入
\begin{awkcode}
    awk '$3 == 0 { print $1 }' emp.data
\end{awkcode}
模式 \verb'$3 == 0' 匹配第三个字段为零的行, 动作
\begin{awkcode}
    { print $1 }
\end{awkcode}
打印该行的第一个字段.

当你阅读这本书时, 请尝试运行并修改书中的程序. 由于大多数程序都很简短, 你可
以快速理解 awk 是怎么工作的. 在一个 Unix 系统终端上, 上面提到的两个例子看
起来就像这样
\begin{shell}
    $ awk '$3 > 0 { print $1, $2 * $3 }' emp.data
    Kathy 40
    Mark 100
    Mary 121
    Susie 76.5
    $ awk '$3 == 0 { print $1 }' emp.data
    Beth
    Dan
    $
\end{shell}
一行开头的字符 \verb'$' 是系统的提示符, 在你的机器上或许会不一样.

\subsection{AWK 程序的结构}
\label{subsec:the_structure_of_an_awk_program}

现在让我们回退一步, 看一下到底发生了什么. 在上面的命令行中, 被单引号包围的
部分是使用 awk 语言编写的程序. 这一章中的每一个 awk 程序都是由一个或多个
模式-动作语句组成的序列:
\begin{pattern}
    \textit{pattern} \texttt{\{} \textit{action} \texttt{\}}
    \textit{pattern} \texttt{\{} \textit{action} \texttt{\}}
    ...
\end{pattern}
awk 的基本操作是在由输入行组成的序列中, 一个接一个地扫描每一行, 搜索被程序
中的模式 \cterm{匹配} (\term{match}) 的行.
\cterm{匹配}的精确含义依赖于问题中 的模式, 对于模式, 例如 \verb'$3 > 0',
意味着条件为真.

\marginpar{3}
每一个输入行轮流被每一个模式测试. 每匹配一个模式, 对应的动作 (可能包含多个
步骤) 就会执行. 然后下一行被读取, 匹配重新开始. 这个过程会一起持续
到所有的输入被读完为止.

上面的程序是模式与动作的典型例子
\begin{awkcode}
    $3 == 0 { print $1 }
\end{awkcode}
是一个单一的模式-动作语句, 对于每一个第3个字段为零的行, 它的第一个字段都会
被打印.

在一个模式-动作语句, 模式或动作可以省略其一, 但不能两者同时被省略. 如果一个
模式没有动作, 例如
\begin{awkcode}
    $3 == 0
\end{awkcode}
会将每一个匹配行 (也就是条件判断为真的行) 打印出来. 这个程序会被文件
\filename{emp.data} 中第3个字段为0的两行打印出来:
\begin{file}
    Beth    4.00    0
    Dan     3.75    0
\end{file}

如果只有动作而没有模式, 例如
\begin{awkcode}
    { print $1 }
\end{awkcode}
对于每一个输入行, 动作 (在这个例子里是打印第1个字段) 都会被执行.

因为模式与动作都是可选的, 所以用花括号将动作包围起来, 以便区分两者.

\subsection{运行 AWK 程序}
\label{running_an_awk_program}

运行一个 awk 程序有多种方式. 你可以键入下面这种形式的命令
\begin{pattern}
    \texttt{awk} \texttt{'}\textit{program}\texttt{'} \textit{input files}
\end{pattern}
对指定的输入文件的每一行运行程序 \textit{program}. 例如你可以键入
\begin{awkcode}
    awk '$3 == 0 { print $1 }' file1 file2
\end{awkcode}
来打印文件 \filename{file1} 与 \filename{file2} 的每一行的第一个字段,
如果该行的第3个字段为0的话.

你也可以在命令行上省略输入文件, 只要键入
\begin{pattern}
    \texttt{awk} \texttt{'}\textit{program}\texttt{'}
\end{pattern}
在这种情况下, awk 会将 \textit{program} 应用到你接下来在终端输入的内容上面,
直到你键入一个文件结束标志 (Unix 系统是组合键 control-d). 下面是一个在 Unix
的例子
\marginpar{4}
\begin{shell}
    $ awk '$3 == 0 { print $1 print $1 }'
    Beth    4.00    0
    Beth
    Dan     3.75    0
    Dan
    Kathy   3.75    10
    Kathy   3.75    0
    Kathy
    ...
\end{shell}
% TODO: 加粗显示未实现
被计算机打印的字符加粗显示.

这种行为使得用 awk 试验非常容易: 键入程序与数据, 看一下会发生什么. 我们再
次建议你尝试运行并修改书中的程序.

注意到, 命令行中的程序被单引号包围. 这种行为可以保护程序中的字符 (例如
\verb'$') 被 shell 解释, 也可以让程序的长度多于一行.

当程序的长度比较短时 (只有几行), 这种安排会比较方便. 如果程序比较长, 更好的
做法是将它们放在一个单独的文件中, 例如文件名可以叫作 \filename{progfile},
运行时只要键入
\begin{pattern}
    \texttt{awk -f progfile} \textit{optional list of files}
\end{pattern}
选项 \verb'-f' 告诉 awk 从文件中提取程序. 在 \filename{progfile} 出现的地方
可以是任意的文件名.

\subsection{错误}
\label{subsec:errors}

如果你在 awk 程序犯了一个错误, awk 会显示一个诊断信息. 例如, 如果你打错了一
个花括号, 就像这样
\begin{awkcode}
    awk '$3 == 0 [ print $1 }' emp.data
\end{awkcode}
你将会收到一个这样的消息
\begin{file}
    awk: syntax error at source line 1
    context is
            $3 == 0 >>> [ <<<
            extra }
            missing ]
    awk: Bailing out at source line 1
\end{file}
"Syntax error" 意味着你犯了一个语法错误, 这个错误被发现的地方用
\verb'>>> <<<' 标记. "Bailing out" 意味着无法恢复. 有时候, 你可以得到更多的
关于错误的信息, 例如报告了一个不匹配的花括号或括号.

由于发生了语法错误, awk 不会尝试执行这个程序.
然而有些错误直到运行时才会检测到. 例如, 你的程序尝试用 0 作除数, 这时候 awk
会停止处理, 接着报告输入行的行号, 以及程序中尝试进行除法运算的代码所在的
行号.

\section{简单的输出}
\label{sec:simple_output}

\marginpar{5}
本章的余下部分包含了一系列简短并且典型的 awk 程序, 这些程序都是基于对
\filename{emp.data} 文件的处理. 我们会简单地介绍这些程序是怎么工作的, 但
这些例子主要用于阐述有用的操作, 这些操作很容易用 awk 完成, 包括打印字段,
选择输入, 以及变换数据. 我们不会展现 awk 所能做的所有事情, 也不会对这里所
表现出来的特定的东西作过多的细节探究. 但是当你阅读完这一章时, 你将有能力
完成相当数量的工作, 而且会发现阅读后面的章节变得更加容易.

我们主要将程序显示出来, 而不是完整的命令行. 在每一种情况下, 程序或者可以
被包围在一对单引号中, 作为 \awk 命令的第一个参数来运行, 也可以将其放入一
个文件中, 通过带有 \verb'-f' 选项的 \awk 命令来运行.

在 awk 中只有两种类型的数据: 数值与由字符组成的字符串. 文件
\filename{emp.data} 是很典型的待处理数据, 它既含有单词, 也包括数值, 且字
段之间通过制表符或空格分隔.

awk 从它的输入中每次读取一行, 将行分解为一个个的字段, 默认将字段看作是不含
空白或制表符的字符组成的序列. 当前输入行的第一个字段叫作 \verb'$1', 第二个
是 \verb'$2', 依次类推. 一整行记为 \verb'$0'. 每行的字段数有可能不一样.

通常情况下, 我们需要做的是打印每一行的部分或全部字段, 也可能会做一些计算.
这一节中的所有程序都是这种形式.

\subsection{打印每一行}
\label{subsec:printing_every_line}

如果一个动作没有模式, 对于每一个输入行, 该动作都会被执行. 语句 \print 会
打印每一个当前输入行, 所以程序
\begin{awkcode}
    { print }
\end{awkcode}
会将它所有的输入打印到标准输出. 因为 \verb'$0' 表示一整行, 所以程序
\begin{awkcode}
    { print $0 }
\end{awkcode}
做的也是同一件事.

\subsection{打印某些字段}
\label{subsec:printing_certain_fields}

在一个 \print 语句中可以将多个项目打印到同一个输出行中. 打印每一个输入行
的第1与第3个字段的程序是
\begin{awkcode}
    { print $1, $3 }
\end{awkcode}
当 \filename{emp.data} 作为输入时, 它会输出
\marginpar{6}
\begin{file}
    Beth 0
    Dan 0
    Kathy 10
    Mark 20
    Mary 22
    Susie 18
\end{file}
在 \print 语句中由逗号分隔的表达式, 在输出时, 默认用一个空白符分隔. 由
\print 打印的每一行都由一个换行符终止. 这些默认行为都可以修改, 我们将在第
\ref{chap:the_awk_language} 章讨论如何修改.

\subsection{\texttt{NF}, 字段的数量}
\label{subsec:nf_the_number_fields}

有时候, 你必须总是通过 \verb'$1', \verb'$2' 这样的形式引用字段, 但是任何表
达式都可以出现在 \verb'$' 的后面, 来指明一个字段的号码; 表达式被求值, 求出
的值被当作字段的号码. Awk 计算当前输入行的字段数量, 并将它存储在一个内建的
变量中, 这个变量叫作 \nf. 因此程序
\begin{awkcode}
    { print NF, $1, $NF }
\end{awkcode}
将会打印每一个输入行的字段数量, 第一个字段, 以及最后一个字段.

\subsection{计算和打印}
\label{subsec:computing_and_printing}

你也可以用字段值进行计算, 并将计算得到的值放在输入语句中. 程序
\begin{awkcode}
    { print $1, $2 * $3 }
\end{awkcode}
是一个很典型的例如. 它会打印雇员的名字与报酬 (每小时工资乘以工作时长):
\begin{file}
    Beth 0
    Dan 0
    Kathy 40
    Mark 100
    Mary 121
    Susie 76.5
\end{file}
我们待会就会展示如果将输出做得更好看.
